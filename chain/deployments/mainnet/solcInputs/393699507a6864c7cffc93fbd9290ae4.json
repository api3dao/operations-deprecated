{
  "language": "Solidity",
  "sources": {
    "contracts/DapiServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"@api3/airnode-protocol-v1/contracts/dapis/DapiServer.sol\";\n"
    },
    "@api3/airnode-protocol-v1/contracts/dapis/DapiServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity 0.8.9;\n\nimport \"../utils/ExtendedMulticall.sol\";\nimport \"../whitelist/WhitelistWithManager.sol\";\nimport \"../protocol/AirnodeRequester.sol\";\nimport \"./Median.sol\";\nimport \"./interfaces/IDapiServer.sol\";\nimport \"@openzeppelin/contracts/utils/cryptography/ECDSA.sol\";\n\n/// @title Contract that serves Beacons, Beacon sets and dAPIs based on the\n/// Airnode protocol\n/// @notice A Beacon is a live data feed addressed by an ID, which is derived\n/// from an Airnode address and a template ID. This is suitable where the more\n/// recent data point is always more favorable, e.g., in the context of an\n/// asset price data feed. Beacons can also be seen as one-Airnode data feeds\n/// that can be used individually or combined to build Beacon sets. dAPIs are\n/// an abstraction layer over Beacons and Beacon sets.\n/// @dev DapiServer is a PSP requester contract. Unlike RRP, which is\n/// implemented as a central contract, PSP implementation is built into the\n/// requester for optimization. Accordingly, the checks that are not required\n/// are omitted. Some examples:\n/// - While executing a PSP Beacon update, the condition is not verified\n/// because Beacon updates where the condition returns `false` (i.e., the\n/// on-chain value is already close to the actual value) are not harmful, and\n/// are even desirable.\n/// - PSP Beacon set update subscription IDs are not verified, as the\n/// Airnode/relayer cannot be made to \"misreport a Beacon set update\" by\n/// spoofing a subscription ID.\n/// - While executing a PSP Beacon set update, even the signature is not\n/// checked because this is a purely keeper job that does not require off-chain\n/// data. Similar to Beacon updates, any Beacon set update is welcome.\ncontract DapiServer is\n    ExtendedMulticall,\n    WhitelistWithManager,\n    AirnodeRequester,\n    Median,\n    IDapiServer\n{\n    using ECDSA for bytes32;\n\n    // Airnodes serve their fulfillment data along with timestamps. This\n    // contract casts the reported data to `int224` and the timestamp to\n    // `uint32`, which works until year 2106.\n    struct DataFeed {\n        int224 value;\n        uint32 timestamp;\n    }\n\n    /// @notice dAPI name setter role description\n    string public constant override DAPI_NAME_SETTER_ROLE_DESCRIPTION =\n        \"dAPI name setter\";\n\n    /// @notice Number that represents 100%\n    /// @dev 10^8 (and not a larger number) is chosen to avoid overflows in\n    /// `calculateUpdateInPercentage()`. Since the reported data needs to fit\n    /// into 224 bits, its multiplication by 10^8 is guaranteed not to\n    /// overflow.\n    uint256 public constant override HUNDRED_PERCENT = 1e8;\n\n    /// @notice dAPI name setter role\n    bytes32 public immutable override dapiNameSetterRole;\n\n    /// @notice If an account is an unlimited reader\n    mapping(address => bool) public unlimitedReaderStatus;\n\n    /// @notice If a sponsor has permitted an account to request RRP-based\n    /// updates at this contract\n    mapping(address => mapping(address => bool))\n        public\n        override sponsorToRrpBeaconUpdateRequesterToPermissionStatus;\n\n    /// @notice ID of the Beacon that the subscription is registered to update\n    mapping(bytes32 => bytes32) public override subscriptionIdToBeaconId;\n\n    mapping(bytes32 => DataFeed) private dataFeeds;\n\n    mapping(bytes32 => bytes32) private requestIdToBeaconId;\n\n    mapping(bytes32 => bytes32) private subscriptionIdToHash;\n\n    mapping(bytes32 => bytes32) private dapiNameHashToDataFeedId;\n\n    /// @dev Reverts if the sender is not permitted to request an RRP-based\n    /// update with the sponsor and is not the sponsor\n    /// @param sponsor Sponsor address\n    modifier onlyPermittedUpdateRequester(address sponsor) {\n        require(\n            sponsor == msg.sender ||\n                sponsorToRrpBeaconUpdateRequesterToPermissionStatus[sponsor][\n                    msg.sender\n                ],\n            \"Sender not permitted\"\n        );\n        _;\n    }\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    /// @param _airnodeProtocol AirnodeProtocol contract address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager,\n        address _airnodeProtocol\n    )\n        WhitelistWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n        AirnodeRequester(_airnodeProtocol)\n    {\n        dapiNameSetterRole = _deriveRole(\n            _deriveAdminRole(manager),\n            keccak256(abi.encodePacked(DAPI_NAME_SETTER_ROLE_DESCRIPTION))\n        );\n    }\n\n    ///                     ~~~RRP Beacon updates~~~\n\n    /// @notice Called by the sponsor to set the update request permission\n    /// status of an account\n    /// @param rrpBeaconUpdateRequester RRP-based Beacon update requester\n    /// address\n    /// @param status Permission status\n    function setRrpBeaconUpdatePermissionStatus(\n        address rrpBeaconUpdateRequester,\n        bool status\n    ) external override {\n        require(\n            rrpBeaconUpdateRequester != address(0),\n            \"Update requester zero\"\n        );\n        sponsorToRrpBeaconUpdateRequesterToPermissionStatus[msg.sender][\n            rrpBeaconUpdateRequester\n        ] = status;\n        emit SetRrpBeaconUpdatePermissionStatus(\n            msg.sender,\n            rrpBeaconUpdateRequester,\n            status\n        );\n    }\n\n    /// @notice Creates an RRP requests for the Beacon to be updated\n    /// @dev In addition to the sponsor sponsoring this contract (by calling\n    /// `setRrpSponsorshipStatus()`), the sponsor must also give update request\n    /// permission to the sender (by calling\n    /// `setRrpBeaconUpdatePermissionStatus()`) before this method is called.\n    /// The template must specify a single point of data of type `int256` to be\n    /// returned and for it to be small enough to be castable to `int224`\n    /// because this is what `fulfillRrpBeaconUpdate()` expects.\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @param sponsor Sponsor address\n    /// @return requestId Request ID\n    function requestRrpBeaconUpdate(\n        address airnode,\n        bytes32 templateId,\n        address sponsor\n    )\n        external\n        override\n        onlyPermittedUpdateRequester(sponsor)\n        returns (bytes32 requestId)\n    {\n        bytes32 beaconId = deriveBeaconId(airnode, templateId);\n        requestId = IAirnodeProtocol(airnodeProtocol).makeRequest(\n            airnode,\n            templateId,\n            \"\",\n            sponsor,\n            this.fulfillRrpBeaconUpdate.selector\n        );\n        requestIdToBeaconId[requestId] = beaconId;\n        emit RequestedRrpBeaconUpdate(\n            beaconId,\n            sponsor,\n            msg.sender,\n            requestId,\n            airnode,\n            templateId\n        );\n    }\n\n    /// @notice Creates an RRP requests for the Beacon to be updated by the relayer\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @param relayer Relayer address\n    /// @param sponsor Sponsor address\n    /// @return requestId Request ID\n    function requestRrpBeaconUpdateRelayed(\n        address airnode,\n        bytes32 templateId,\n        address relayer,\n        address sponsor\n    )\n        external\n        override\n        onlyPermittedUpdateRequester(sponsor)\n        returns (bytes32 requestId)\n    {\n        bytes32 beaconId = deriveBeaconId(airnode, templateId);\n        requestId = IAirnodeProtocol(airnodeProtocol).makeRequestRelayed(\n            airnode,\n            templateId,\n            \"\",\n            relayer,\n            sponsor,\n            this.fulfillRrpBeaconUpdate.selector\n        );\n        requestIdToBeaconId[requestId] = beaconId;\n        emit RequestedRrpBeaconUpdateRelayed(\n            beaconId,\n            sponsor,\n            msg.sender,\n            requestId,\n            airnode,\n            relayer,\n            templateId\n        );\n    }\n\n    /// @notice Called by the Airnode/relayer using the sponsor wallet through\n    /// AirnodeProtocol to fulfill the request\n    /// @param requestId Request ID\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    function fulfillRrpBeaconUpdate(\n        bytes32 requestId,\n        uint256 timestamp,\n        bytes calldata data\n    ) external override onlyAirnodeProtocol onlyValidTimestamp(timestamp) {\n        bytes32 beaconId = requestIdToBeaconId[requestId];\n        delete requestIdToBeaconId[requestId];\n        int256 decodedData = processBeaconUpdate(beaconId, timestamp, data);\n        emit UpdatedBeaconWithRrp(beaconId, requestId, decodedData, timestamp);\n    }\n\n    ///                     ~~~PSP Beacon updates~~~\n\n    /// @notice Registers the Beacon update subscription\n    /// @dev Similar to how one needs to call `requestRrpBeaconUpdate()` for\n    /// this contract to recognize the incoming RRP fulfillment, this needs to\n    /// be called before the subscription fulfillments.\n    /// In addition to the subscription being registered, the sponsor must use\n    /// `setPspSponsorshipStatus()` to give permission for its sponsor wallet\n    /// to be used for the specific subscription.\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @param conditions Conditions under which the subscription is requested\n    /// to be fulfilled\n    /// @param relayer Relayer address\n    /// @param sponsor Sponsor address\n    /// @return subscriptionId Subscription ID\n    function registerBeaconUpdateSubscription(\n        address airnode,\n        bytes32 templateId,\n        bytes memory conditions,\n        address relayer,\n        address sponsor\n    ) external override returns (bytes32 subscriptionId) {\n        require(relayer != address(0), \"Relayer address zero\");\n        require(sponsor != address(0), \"Sponsor address zero\");\n        subscriptionId = keccak256(\n            abi.encode(\n                block.chainid,\n                airnode,\n                templateId,\n                \"\",\n                conditions,\n                relayer,\n                sponsor,\n                address(this),\n                this.fulfillPspBeaconUpdate.selector\n            )\n        );\n        subscriptionIdToHash[subscriptionId] = keccak256(\n            abi.encodePacked(airnode, relayer, sponsor)\n        );\n        subscriptionIdToBeaconId[subscriptionId] = deriveBeaconId(\n            airnode,\n            templateId\n        );\n        emit RegisteredBeaconUpdateSubscription(\n            subscriptionId,\n            airnode,\n            templateId,\n            \"\",\n            conditions,\n            relayer,\n            sponsor,\n            address(this),\n            this.fulfillPspBeaconUpdate.selector\n        );\n    }\n\n    /// @notice Returns if the respective Beacon needs to be updated based on\n    /// the fulfillment data and the condition parameters\n    /// @dev Reverts if not called by a void signer with zero address because\n    /// this method can be used to indirectly read a Beacon.\n    /// `conditionParameters` are specified within the `conditions` field of a\n    /// Subscription.\n    /// @param subscriptionId Subscription ID\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @param conditionParameters Subscription condition parameters (a\n    /// `uint256` encoded in contract ABI)\n    /// @return If the Beacon update subscription should be fulfilled\n    function conditionPspBeaconUpdate(\n        bytes32 subscriptionId,\n        bytes calldata data,\n        bytes calldata conditionParameters\n    ) external view override returns (bool) {\n        require(msg.sender == address(0), \"Sender not zero address\");\n        bytes32 beaconId = subscriptionIdToBeaconId[subscriptionId];\n        require(beaconId != bytes32(0), \"Subscription not registered\");\n        DataFeed storage beacon = dataFeeds[beaconId];\n        return\n            calculateUpdateInPercentage(\n                beacon.value,\n                decodeFulfillmentData(data)\n            ) >=\n            decodeConditionParameters(conditionParameters) ||\n            beacon.timestamp == 0;\n    }\n\n    /// @notice Called by the Airnode/relayer using the sponsor wallet to\n    /// fulfill the Beacon update subscription\n    /// @dev There is no need to verify that `conditionPspBeaconUpdate()`\n    /// returns `true` because any Beacon update is a good Beacon update\n    /// @param subscriptionId Subscription ID\n    /// @param airnode Airnode address\n    /// @param relayer Relayer address\n    /// @param sponsor Sponsor address\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Fulfillment data (a single `int256` encoded in contract\n    /// ABI)\n    /// @param signature Subscription ID, timestamp, sponsor wallet address\n    /// (and fulfillment data if the relayer is not the Airnode) signed by the\n    /// Airnode wallet\n    function fulfillPspBeaconUpdate(\n        bytes32 subscriptionId,\n        address airnode,\n        address relayer,\n        address sponsor,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external override onlyValidTimestamp(timestamp) {\n        require(\n            subscriptionIdToHash[subscriptionId] ==\n                keccak256(abi.encodePacked(airnode, relayer, sponsor)),\n            \"Subscription not registered\"\n        );\n        if (airnode == relayer) {\n            require(\n                (\n                    keccak256(\n                        abi.encodePacked(subscriptionId, timestamp, msg.sender)\n                    ).toEthSignedMessageHash()\n                ).recover(signature) == airnode,\n                \"Signature mismatch\"\n            );\n        } else {\n            require(\n                (\n                    keccak256(\n                        abi.encodePacked(\n                            subscriptionId,\n                            timestamp,\n                            msg.sender,\n                            data\n                        )\n                    ).toEthSignedMessageHash()\n                ).recover(signature) == airnode,\n                \"Signature mismatch\"\n            );\n        }\n        bytes32 beaconId = subscriptionIdToBeaconId[subscriptionId];\n        // Beacon ID is guaranteed to not be zero because the subscription is\n        // registered\n        int256 decodedData = processBeaconUpdate(beaconId, timestamp, data);\n        emit UpdatedBeaconWithPsp(\n            beaconId,\n            subscriptionId,\n            int224(decodedData),\n            uint32(timestamp)\n        );\n    }\n\n    ///                     ~~~Signed data Beacon updates~~~\n\n    /// @notice Updates a Beacon using data signed by the respective Airnode,\n    /// without requiring a request or subscription\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Response data (an `int256` encoded in contract ABI)\n    /// @param signature Template ID, a timestamp and the response data signed\n    /// by the Airnode address\n    function updateBeaconWithSignedData(\n        address airnode,\n        bytes32 templateId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external override onlyValidTimestamp(timestamp) {\n        require(\n            (\n                keccak256(abi.encodePacked(templateId, timestamp, data))\n                    .toEthSignedMessageHash()\n            ).recover(signature) == airnode,\n            \"Signature mismatch\"\n        );\n        bytes32 beaconId = deriveBeaconId(airnode, templateId);\n        int256 decodedData = processBeaconUpdate(beaconId, timestamp, data);\n        emit UpdatedBeaconWithSignedData(beaconId, decodedData, timestamp);\n    }\n\n    ///                     ~~~PSP Beacon set updates~~~\n\n    /// @notice Updates the Beacon set using the current values of its Beacons\n    /// @dev This function still works if some of the IDs in `beaconIds` belong\n    /// to Beacon sets rather than Beacons. However, this is not the intended\n    /// use.\n    /// @param beaconIds Beacon IDs\n    /// @return beaconSetId Beacon set ID\n    function updateBeaconSetWithBeacons(bytes32[] memory beaconIds)\n        public\n        override\n        returns (bytes32 beaconSetId)\n    {\n        uint256 beaconCount = beaconIds.length;\n        require(beaconCount > 1, \"Specified less than two Beacons\");\n        int256[] memory values = new int256[](beaconCount);\n        uint256 accumulatedTimestamp = 0;\n        for (uint256 ind = 0; ind < beaconCount; ind++) {\n            DataFeed storage dataFeed = dataFeeds[beaconIds[ind]];\n            values[ind] = dataFeed.value;\n            accumulatedTimestamp += dataFeed.timestamp;\n        }\n        uint32 updatedTimestamp = uint32(accumulatedTimestamp / beaconCount);\n        beaconSetId = deriveBeaconSetId(beaconIds);\n        require(\n            updatedTimestamp >= dataFeeds[beaconSetId].timestamp,\n            \"Updated value outdated\"\n        );\n        int224 updatedValue = int224(median(values));\n        dataFeeds[beaconSetId] = DataFeed({\n            value: updatedValue,\n            timestamp: updatedTimestamp\n        });\n        emit UpdatedBeaconSetWithBeacons(\n            beaconSetId,\n            updatedValue,\n            updatedTimestamp\n        );\n    }\n\n    /// @notice Updates the Beacon set using the current values of the Beacons\n    /// and returns if this update was justified according to the deviation\n    /// threshold\n    /// @dev This method does not allow the caller to indirectly read a Beacon\n    /// set, which is why it does not require the sender to be a void signer\n    /// with zero address. This allows the implementation of incentive\n    /// mechanisms that rewards keepers that trigger valid dAPI updates.\n    /// @param beaconIds Beacon IDs\n    /// @param deviationThresholdInPercentage Deviation threshold in percentage\n    /// where 100% is represented as `HUNDRED_PERCENT`\n    function updateBeaconSetWithBeaconsAndReturnCondition(\n        bytes32[] memory beaconIds,\n        uint256 deviationThresholdInPercentage\n    ) public override returns (bool) {\n        bytes32 beaconSetId = deriveBeaconSetId(beaconIds);\n        DataFeed memory initialBeaconSet = dataFeeds[beaconSetId];\n        updateBeaconSetWithBeacons(beaconIds);\n        DataFeed storage updatedBeaconSet = dataFeeds[beaconSetId];\n        return\n            calculateUpdateInPercentage(\n                initialBeaconSet.value,\n                updatedBeaconSet.value\n            ) >=\n            deviationThresholdInPercentage ||\n            (initialBeaconSet.timestamp == 0 && updatedBeaconSet.timestamp > 0);\n    }\n\n    /// @notice Returns if the respective Beacon set needs to be updated based\n    /// on the condition parameters\n    /// @dev The template ID used in the respective Subscription is expected to\n    /// be zero, which means the `parameters` field of the Subscription will be\n    /// forwarded to this function as `data`. This field should be the Beacon\n    /// ID array encoded in contract ABI.\n    /// @param subscriptionId Subscription ID\n    /// @param data Fulfillment data (array of Beacon IDs, i.e., `bytes32[]`\n    /// encoded in contract ABI)\n    /// @param conditionParameters Subscription condition parameters (a\n    /// `uint256` encoded in contract ABI)\n    /// @return If the Beacon set update subscription should be fulfilled\n    function conditionPspBeaconSetUpdate(\n        bytes32 subscriptionId, // solhint-disable-line no-unused-vars\n        bytes calldata data,\n        bytes calldata conditionParameters\n    ) external override returns (bool) {\n        require(msg.sender == address(0), \"Sender not zero address\");\n        bytes32[] memory beaconIds = abi.decode(data, (bytes32[]));\n        require(\n            keccak256(abi.encode(beaconIds)) == keccak256(data),\n            \"Data length not correct\"\n        );\n        return\n            updateBeaconSetWithBeaconsAndReturnCondition(\n                beaconIds,\n                decodeConditionParameters(conditionParameters)\n            );\n    }\n\n    /// @notice Called by the Airnode/relayer using the sponsor wallet to\n    /// fulfill the Beacon set update subscription\n    /// @dev Similar to `conditionPspBeaconSetUpdate()`, if `templateId` of the\n    /// Subscription is zero, its `parameters` field will be forwarded to\n    /// `data` here, which is expect to be contract ABI-encoded array of Beacon\n    /// IDs.\n    /// It does not make sense for this subscription to be relayed, as there is\n    /// no external data being delivered. Nevertheless, this is allowed for the\n    /// lack of a reason to prevent it.\n    /// Even though the consistency of the arguments are not being checked, if\n    /// a standard implementation of Airnode is being used, these can be\n    /// expected to be correct. Either way, the assumption is that it does not\n    /// matter for the purposes of a Beacon set update subscription.\n    /// @param subscriptionId Subscription ID\n    /// @param airnode Airnode address\n    /// @param relayer Relayer address\n    /// @param sponsor Sponsor address\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @param signature Subscription ID, timestamp, sponsor wallet address\n    /// (and fulfillment data if the relayer is not the Airnode) signed by the\n    /// Airnode wallet\n    function fulfillPspBeaconSetUpdate(\n        bytes32 subscriptionId, // solhint-disable-line no-unused-vars\n        address airnode, // solhint-disable-line no-unused-vars\n        address relayer, // solhint-disable-line no-unused-vars\n        address sponsor, // solhint-disable-line no-unused-vars\n        uint256 timestamp, // solhint-disable-line no-unused-vars\n        bytes calldata data,\n        bytes calldata signature // solhint-disable-line no-unused-vars\n    ) external override {\n        require(\n            keccak256(data) ==\n                updateBeaconSetWithBeacons(abi.decode(data, (bytes32[]))),\n            \"Data length not correct\"\n        );\n    }\n\n    ///                     ~~~Signed data Beacon set updates~~~\n\n    /// @notice Updates a Beacon set using data signed by the respective\n    /// Airnodes without requiring a request or subscription. The Beacons for\n    /// which the signature is omitted will be read from the storage.\n    /// @param airnodes Airnode addresses\n    /// @param templateIds Template IDs\n    /// @param timestamps Timestamps used in the signatures\n    /// @param data Response data (an `int256` encoded in contract ABI per\n    /// Beacon)\n    /// @param signatures Template ID, a timestamp and the response data signed\n    /// by the respective Airnode address per Beacon\n    /// @return beaconSetId Beacon set ID\n    function updateBeaconSetWithSignedData(\n        address[] memory airnodes,\n        bytes32[] memory templateIds,\n        uint256[] memory timestamps,\n        bytes[] memory data,\n        bytes[] memory signatures\n    ) external override returns (bytes32 beaconSetId) {\n        uint256 beaconCount = airnodes.length;\n        require(\n            beaconCount == templateIds.length &&\n                beaconCount == timestamps.length &&\n                beaconCount == data.length &&\n                beaconCount == signatures.length,\n            \"Parameter length mismatch\"\n        );\n        require(beaconCount > 1, \"Specified less than two Beacons\");\n        bytes32[] memory beaconIds = new bytes32[](beaconCount);\n        int256[] memory values = new int256[](beaconCount);\n        uint256 accumulatedTimestamp = 0;\n        for (uint256 ind = 0; ind < beaconCount; ind++) {\n            if (signatures[ind].length != 0) {\n                address airnode = airnodes[ind];\n                uint256 timestamp = timestamps[ind];\n                require(timestampIsValid(timestamp), \"Timestamp not valid\");\n                require(\n                    (\n                        keccak256(\n                            abi.encodePacked(\n                                templateIds[ind],\n                                timestamp,\n                                data[ind]\n                            )\n                        ).toEthSignedMessageHash()\n                    ).recover(signatures[ind]) == airnode,\n                    \"Signature mismatch\"\n                );\n                values[ind] = decodeFulfillmentData(data[ind]);\n                // Timestamp validity is already checked, which means it will\n                // be small enough to be typecast into `uint32`\n                accumulatedTimestamp += timestamp;\n                beaconIds[ind] = deriveBeaconId(airnode, templateIds[ind]);\n            } else {\n                bytes32 beaconId = deriveBeaconId(\n                    airnodes[ind],\n                    templateIds[ind]\n                );\n                DataFeed storage dataFeed = dataFeeds[beaconId];\n                values[ind] = dataFeed.value;\n                accumulatedTimestamp += dataFeed.timestamp;\n                beaconIds[ind] = beaconId;\n            }\n        }\n        beaconSetId = deriveBeaconSetId(beaconIds);\n        uint32 updatedTimestamp = uint32(accumulatedTimestamp / beaconCount);\n        require(\n            updatedTimestamp >= dataFeeds[beaconSetId].timestamp,\n            \"Updated value outdated\"\n        );\n        int224 updatedValue = int224(median(values));\n        dataFeeds[beaconSetId] = DataFeed({\n            value: updatedValue,\n            timestamp: updatedTimestamp\n        });\n        emit UpdatedBeaconSetWithSignedData(\n            beaconSetId,\n            updatedValue,\n            updatedTimestamp\n        );\n    }\n\n    /// @notice Called by the manager to add the unlimited reader indefinitely\n    /// @dev Since the unlimited reader status cannot be revoked, only\n    /// contracts that are adequately restricted should be given this status\n    /// @param unlimitedReader Unlimited reader address\n    function addUnlimitedReader(address unlimitedReader) external override {\n        require(msg.sender == manager, \"Sender not manager\");\n        unlimitedReaderStatus[unlimitedReader] = true;\n        emit AddedUnlimitedReader(unlimitedReader);\n    }\n\n    /// @notice Sets the data feed ID the dAPI name points to\n    /// @dev While a data feed ID refers to a specific Beacon or Beacon set,\n    /// dAPI names provide a more abstract interface for convenience. This\n    /// means a dAPI name that was pointing to a Beacon can be pointed to a\n    /// Beacon set, then another Beacon set, etc.\n    /// @param dapiName Human-readable dAPI name\n    /// @param dataFeedId Data feed ID the dAPI name will point to\n    function setDapiName(bytes32 dapiName, bytes32 dataFeedId)\n        external\n        override\n    {\n        require(dapiName != bytes32(0), \"dAPI name zero\");\n        require(\n            msg.sender == manager ||\n                IAccessControlRegistry(accessControlRegistry).hasRole(\n                    dapiNameSetterRole,\n                    msg.sender\n                ),\n            \"Sender cannot set dAPI name\"\n        );\n        dapiNameHashToDataFeedId[\n            keccak256(abi.encodePacked(dapiName))\n        ] = dataFeedId;\n        emit SetDapiName(dapiName, dataFeedId, msg.sender);\n    }\n\n    /// @notice Returns the data feed ID the dAPI name is set to\n    /// @param dapiName dAPI name\n    /// @return Data feed ID\n    function dapiNameToDataFeedId(bytes32 dapiName)\n        external\n        view\n        override\n        returns (bytes32)\n    {\n        return dapiNameHashToDataFeedId[keccak256(abi.encodePacked(dapiName))];\n    }\n\n    /// @notice Reads the data feed with ID\n    /// @param dataFeedId Data feed ID\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function readDataFeedWithId(bytes32 dataFeedId)\n        external\n        view\n        override\n        returns (int224 value, uint32 timestamp)\n    {\n        require(\n            readerCanReadDataFeed(dataFeedId, msg.sender),\n            \"Sender cannot read\"\n        );\n        DataFeed storage dataFeed = dataFeeds[dataFeedId];\n        return (dataFeed.value, dataFeed.timestamp);\n    }\n\n    /// @notice Reads the data feed value with ID\n    /// @param dataFeedId Data feed ID\n    /// @return value Data feed value\n    function readDataFeedValueWithId(bytes32 dataFeedId)\n        external\n        view\n        override\n        returns (int224 value)\n    {\n        require(\n            readerCanReadDataFeed(dataFeedId, msg.sender),\n            \"Sender cannot read\"\n        );\n        DataFeed storage dataFeed = dataFeeds[dataFeedId];\n        require(dataFeed.timestamp != 0, \"Data feed does not exist\");\n        return dataFeed.value;\n    }\n\n    /// @notice Reads the data feed with dAPI name\n    /// @dev The read data feed may belong to a Beacon or dAPI. The reader\n    /// must be whitelisted for the hash of the dAPI name.\n    /// @param dapiName dAPI name\n    /// @return value Data feed value\n    /// @return timestamp Data feed timestamp\n    function readDataFeedWithDapiName(bytes32 dapiName)\n        external\n        view\n        override\n        returns (int224 value, uint32 timestamp)\n    {\n        bytes32 dapiNameHash = keccak256(abi.encodePacked(dapiName));\n        require(\n            readerCanReadDataFeed(dapiNameHash, msg.sender),\n            \"Sender cannot read\"\n        );\n        bytes32 dataFeedId = dapiNameHashToDataFeedId[dapiNameHash];\n        require(dataFeedId != bytes32(0), \"dAPI name not set\");\n        DataFeed storage dataFeed = dataFeeds[dataFeedId];\n        return (dataFeed.value, dataFeed.timestamp);\n    }\n\n    /// @notice Reads the data feed value with dAPI name\n    /// @param dapiName dAPI name\n    /// @return value Data feed value\n    function readDataFeedValueWithDapiName(bytes32 dapiName)\n        external\n        view\n        override\n        returns (int224 value)\n    {\n        bytes32 dapiNameHash = keccak256(abi.encodePacked(dapiName));\n        require(\n            readerCanReadDataFeed(dapiNameHash, msg.sender),\n            \"Sender cannot read\"\n        );\n        DataFeed storage dataFeed = dataFeeds[\n            dapiNameHashToDataFeedId[dapiNameHash]\n        ];\n        require(dataFeed.timestamp != 0, \"Data feed does not exist\");\n        return dataFeed.value;\n    }\n\n    /// @notice Returns if a reader can read the data feed\n    /// @param dataFeedId Data feed ID (or dAPI name hash)\n    /// @param reader Reader address\n    /// @return If the reader can read the data feed\n    function readerCanReadDataFeed(bytes32 dataFeedId, address reader)\n        public\n        view\n        override\n        returns (bool)\n    {\n        return\n            reader == address(0) ||\n            userIsWhitelisted(dataFeedId, reader) ||\n            unlimitedReaderStatus[reader];\n    }\n\n    /// @notice Returns the detailed whitelist status of the reader for the\n    /// data feed\n    /// @param dataFeedId Data feed ID (or dAPI name hash)\n    /// @param reader Reader address\n    /// @return expirationTimestamp Timestamp at which the whitelisting of the\n    /// reader will expire\n    /// @return indefiniteWhitelistCount Number of times `reader` was\n    /// whitelisted indefinitely for `dataFeedId`\n    function dataFeedIdToReaderToWhitelistStatus(\n        bytes32 dataFeedId,\n        address reader\n    )\n        external\n        view\n        override\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                dataFeedId\n            ][reader];\n        expirationTimestamp = whitelistStatus.expirationTimestamp;\n        indefiniteWhitelistCount = whitelistStatus.indefiniteWhitelistCount;\n    }\n\n    /// @notice Returns if an account has indefinitely whitelisted the reader\n    /// for the data feed\n    /// @param dataFeedId Data feed ID (or dAPI name hash)\n    /// @param reader Reader address\n    /// @param setter Address of the account that has potentially whitelisted\n    /// the reader for the data feed indefinitely\n    /// @return indefiniteWhitelistStatus If `setter` has indefinitely\n    /// whitelisted reader for the data feed\n    function dataFeedIdToReaderToSetterToIndefiniteWhitelistStatus(\n        bytes32 dataFeedId,\n        address reader,\n        address setter\n    ) external view override returns (bool indefiniteWhitelistStatus) {\n        indefiniteWhitelistStatus = serviceIdToUserToSetterToIndefiniteWhitelistStatus[\n            dataFeedId\n        ][reader][setter];\n    }\n\n    /// @notice Derives the Beacon ID from the Airnode address and template ID\n    /// @param airnode Airnode address\n    /// @param templateId Template ID\n    /// @return beaconId Beacon ID\n    function deriveBeaconId(address airnode, bytes32 templateId)\n        public\n        pure\n        override\n        returns (bytes32 beaconId)\n    {\n        require(airnode != address(0), \"Airnode address zero\");\n        require(templateId != bytes32(0), \"Template ID zero\");\n        beaconId = keccak256(abi.encodePacked(airnode, templateId));\n    }\n\n    /// @notice Derives the Beacon set ID from the Beacon IDs\n    /// @dev Notice that `abi.encode()` is used over `abi.encodePacked()`\n    /// @param beaconIds Beacon IDs\n    /// @return beaconSetId Beacon set ID\n    function deriveBeaconSetId(bytes32[] memory beaconIds)\n        public\n        pure\n        override\n        returns (bytes32 beaconSetId)\n    {\n        beaconSetId = keccak256(abi.encode(beaconIds));\n    }\n\n    /// @notice Called privately to process the Beacon update\n    /// @param beaconId Beacon ID\n    /// @param timestamp Timestamp used in the signature\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @return updatedBeaconValue Updated Beacon value\n    function processBeaconUpdate(\n        bytes32 beaconId,\n        uint256 timestamp,\n        bytes calldata data\n    ) private returns (int256 updatedBeaconValue) {\n        updatedBeaconValue = decodeFulfillmentData(data);\n        require(\n            timestamp > dataFeeds[beaconId].timestamp,\n            \"Fulfillment older than Beacon\"\n        );\n        // Timestamp validity is already checked by `onlyValidTimestamp`, which\n        // means it will be small enough to be typecast into `uint32`\n        dataFeeds[beaconId] = DataFeed({\n            value: int224(updatedBeaconValue),\n            timestamp: uint32(timestamp)\n        });\n    }\n\n    /// @notice Called privately to decode the fulfillment data\n    /// @param data Fulfillment data (an `int256` encoded in contract ABI)\n    /// @return decodedData Decoded fulfillment data\n    function decodeFulfillmentData(bytes memory data)\n        private\n        pure\n        returns (int224)\n    {\n        require(data.length == 32, \"Data length not correct\");\n        int256 decodedData = abi.decode(data, (int256));\n        require(\n            decodedData >= type(int224).min && decodedData <= type(int224).max,\n            \"Value typecasting error\"\n        );\n        return int224(decodedData);\n    }\n\n    /// @notice Called privately to decode the condition parameters\n    /// @param conditionParameters Condition parameters (a `uint256` encoded in\n    /// contract ABI)\n    /// @return deviationThresholdInPercentage Deviation threshold in\n    /// percentage where 100% is represented as `HUNDRED_PERCENT`\n    function decodeConditionParameters(bytes calldata conditionParameters)\n        private\n        pure\n        returns (uint256 deviationThresholdInPercentage)\n    {\n        require(conditionParameters.length == 32, \"Incorrect parameter length\");\n        deviationThresholdInPercentage = abi.decode(\n            conditionParameters,\n            (uint256)\n        );\n    }\n\n    /// @notice Called privately to calculate the update magnitude in\n    /// percentages where 100% is represented as `HUNDRED_PERCENT`\n    /// @dev The percentage changes will be more pronounced when the first\n    /// value is almost zero, which may trigger updates more frequently than\n    /// wanted. To avoid this, Beacons should be defined in a way that the\n    /// expected values are not small numbers floating around zero, i.e.,\n    /// offset and scale.\n    /// @param initialValue Initial value\n    /// @param updatedValue Updated value\n    /// @return updateInPercentage Update in percentage\n    function calculateUpdateInPercentage(\n        int224 initialValue,\n        int224 updatedValue\n    ) private pure returns (uint256 updateInPercentage) {\n        int256 delta = int256(updatedValue) - int256(initialValue);\n        uint256 absoluteDelta = delta > 0 ? uint256(delta) : uint256(-delta);\n        uint256 absoluteInitialValue = initialValue > 0\n            ? uint256(int256(initialValue))\n            : uint256(-int256(initialValue));\n        // Avoid division by 0\n        if (absoluteInitialValue == 0) {\n            absoluteInitialValue = 1;\n        }\n        updateInPercentage =\n            (absoluteDelta * HUNDRED_PERCENT) /\n            absoluteInitialValue;\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/utils/ExtendedMulticall.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\n\n/// @notice Contract that extends the functionality of Multicall to cover the\n/// retrieval of some globally available variables\ncontract ExtendedMulticall is Multicall {\n    /// @notice Returns the chain ID\n    /// @return Chain ID\n    function getChainId() external view returns (uint256) {\n        return block.chainid;\n    }\n\n    /// @notice Returns the account balance\n    /// @param account Account address\n    /// @return Account balance\n    function getBalance(address account) external view returns (uint256) {\n        return account.balance;\n    }\n\n    /// @notice Returns the current block number\n    /// @return Current block number\n    function getBlockNumber() external view returns (uint256) {\n        return block.number;\n    }\n\n    /// @notice Returns the current block timestamp\n    /// @return Current block timestamp\n    function getBlockTimestamp() external view returns (uint256) {\n        return block.timestamp;\n    }\n\n    /// @notice Returns the current block basefee\n    /// @return Current block basefee\n    function getBlockBasefee() external view returns (uint256) {\n        return block.basefee;\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/whitelist/WhitelistWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Whitelist.sol\";\nimport \"./WhitelistRolesWithManager.sol\";\nimport \"./interfaces/IWhitelistWithManager.sol\";\n\n/// @title Contract to be inherited by Whitelist contracts that are controlled\n/// by a manager\ncontract WhitelistWithManager is\n    Whitelist,\n    WhitelistRolesWithManager,\n    IWhitelistWithManager\n{\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        WhitelistRolesWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {}\n\n    /// @notice Extends the expiration of the temporary whitelist of `user` to\n    /// be able to use the service with `serviceId` if the sender has the\n    /// whitelist expiration extender role\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function extendWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasWhitelistExpirationExtenderRoleOrIsManager(msg.sender),\n            \"Cannot extend expiration\"\n        );\n        require(serviceId != bytes32(0), \"Service ID zero\");\n        require(user != address(0), \"User address zero\");\n        _extendWhitelistExpiration(serviceId, user, expirationTimestamp);\n        emit ExtendedWhitelistExpiration(\n            serviceId,\n            user,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of `user` to be\n    /// able to use the service with `serviceId` if the sender has the\n    /// whitelist expiration setter role\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function setWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) external override {\n        require(\n            hasWhitelistExpirationSetterRoleOrIsManager(msg.sender),\n            \"Cannot set expiration\"\n        );\n        require(serviceId != bytes32(0), \"Service ID zero\");\n        require(user != address(0), \"User address zero\");\n        _setWhitelistExpiration(serviceId, user, expirationTimestamp);\n        emit SetWhitelistExpiration(\n            serviceId,\n            user,\n            msg.sender,\n            expirationTimestamp\n        );\n    }\n\n    /// @notice Sets the indefinite whitelist status of `user` to be able to\n    /// use the service with `serviceId` if the sender has the indefinite\n    /// whitelister role\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param status Indefinite whitelist status\n    function setIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        bool status\n    ) external override {\n        require(\n            hasIndefiniteWhitelisterRoleOrIsManager(msg.sender),\n            \"Cannot set indefinite status\"\n        );\n        require(serviceId != bytes32(0), \"Service ID zero\");\n        require(user != address(0), \"User address zero\");\n        uint192 indefiniteWhitelistCount = _setIndefiniteWhitelistStatus(\n            serviceId,\n            user,\n            status\n        );\n        emit SetIndefiniteWhitelistStatus(\n            serviceId,\n            user,\n            msg.sender,\n            status,\n            indefiniteWhitelistCount\n        );\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted by a specific\n    /// account that no longer has the indefinite whitelister role\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param setter Setter of the indefinite whitelist status\n    function revokeIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        address setter\n    ) external override {\n        require(\n            !hasIndefiniteWhitelisterRoleOrIsManager(setter),\n            \"setter can set indefinite status\"\n        );\n        (\n            bool revoked,\n            uint192 indefiniteWhitelistCount\n        ) = _revokeIndefiniteWhitelistStatus(serviceId, user, setter);\n        if (revoked) {\n            emit RevokedIndefiniteWhitelistStatus(\n                serviceId,\n                user,\n                setter,\n                msg.sender,\n                indefiniteWhitelistCount\n            );\n        }\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/protocol/AirnodeRequester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAirnodeProtocol.sol\";\nimport \"./interfaces/IAirnodeRequester.sol\";\n\n/// @title Contract to be inherited by contracts that will make Airnode\n/// requests and receive fulfillments\ncontract AirnodeRequester is IAirnodeRequester {\n    /// @notice AirnodeProtocol contract address\n    address public immutable override airnodeProtocol;\n\n    /// @dev Reverts if the sender is not the AirnodeProtocol contract. Use\n    /// this modifier with methods that are meant to receive RRP fulfillments.\n    modifier onlyAirnodeProtocol() {\n        require(\n            msg.sender == address(airnodeProtocol),\n            \"Sender not Airnode protocol\"\n        );\n        _;\n    }\n\n    /// @dev Reverts if the timestamp is not valid. Use this modifier with\n    /// methods that are meant to receive RRP and PSP fulfillments.\n    /// @param timestamp Timestamp used in the signature\n    modifier onlyValidTimestamp(uint256 timestamp) {\n        require(timestampIsValid(timestamp), \"Timestamp not valid\");\n        _;\n    }\n\n    /// @param _airnodeProtocol AirnodeProtocol contract address\n    constructor(address _airnodeProtocol) {\n        require(_airnodeProtocol != address(0), \"AirnodeProtocol address zero\");\n        airnodeProtocol = _airnodeProtocol;\n    }\n\n    /// @notice Returns if the timestamp used in the signature is valid\n    /// @dev Returns `false` if the timestamp is not at most 1 hour old to\n    /// prevent replays. Returns `false` if the timestamp is not from the past,\n    /// with some leeway to accomodate for some benign time drift. These values\n    /// are appropriate in most cases, but you can adjust them if you are aware\n    /// of the implications.\n    /// @param timestamp Timestamp used in the signature\n    function timestampIsValid(uint256 timestamp) internal view returns (bool) {\n        return\n            timestamp + 1 hours > block.timestamp &&\n            timestamp < block.timestamp + 15 minutes;\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/dapis/Median.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./Sort.sol\";\nimport \"./QuickSelect.sol\";\n\n/// @title Contract to be inherited by contracts that will calculate the median\n/// of an array\n/// @notice The operation will be in-place, i.e., the array provided as the\n/// argument will be modified.\ncontract Median is Sort, Quickselect {\n    /// @notice Returns the median of the array\n    /// @dev Uses an unrolled sorting implementation for shorter arrays and\n    /// quickselect for longer arrays for gas cost efficiency\n    /// @param array Array whose median is to be calculated\n    /// @return Median of the array\n    function median(int256[] memory array) internal pure returns (int256) {\n        uint256 arrayLength = array.length;\n        if (arrayLength <= MAX_SORT_LENGTH) {\n            sort(array);\n            if (arrayLength % 2 == 1) {\n                return array[arrayLength / 2];\n            } else {\n                return\n                    (array[arrayLength / 2 - 1] + array[arrayLength / 2]) / 2;\n            }\n        } else {\n            if (arrayLength % 2 == 1) {\n                return array[quickselectK(array, arrayLength / 2)];\n            } else {\n                (uint256 mid1, uint256 mid2) = quickselectKPlusOne(\n                    array,\n                    arrayLength / 2 - 1\n                );\n                return (array[mid1] + array[mid2]) / 2;\n            }\n        }\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/dapis/interfaces/IDapiServer.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"../../protocol/interfaces/IAirnodeRequester.sol\";\n\ninterface IDapiServer is IAirnodeRequester {\n    event SetRrpBeaconUpdatePermissionStatus(\n        address indexed sponsor,\n        address indexed rrpBeaconUpdateRequester,\n        bool status\n    );\n\n    event RequestedRrpBeaconUpdate(\n        bytes32 indexed beaconId,\n        address indexed sponsor,\n        address indexed requester,\n        bytes32 requestId,\n        address airnode,\n        bytes32 templateId\n    );\n\n    event RequestedRrpBeaconUpdateRelayed(\n        bytes32 indexed beaconId,\n        address indexed sponsor,\n        address indexed requester,\n        bytes32 requestId,\n        address airnode,\n        address relayer,\n        bytes32 templateId\n    );\n\n    event UpdatedBeaconWithRrp(\n        bytes32 indexed beaconId,\n        bytes32 requestId,\n        int256 value,\n        uint256 timestamp\n    );\n\n    event RegisteredBeaconUpdateSubscription(\n        bytes32 indexed subscriptionId,\n        address airnode,\n        bytes32 templateId,\n        bytes parameters,\n        bytes conditions,\n        address relayer,\n        address sponsor,\n        address requester,\n        bytes4 fulfillFunctionId\n    );\n\n    event UpdatedBeaconWithPsp(\n        bytes32 indexed beaconId,\n        bytes32 subscriptionId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    event UpdatedBeaconWithSignedData(\n        bytes32 indexed beaconId,\n        int256 value,\n        uint256 timestamp\n    );\n\n    event UpdatedBeaconSetWithBeacons(\n        bytes32 indexed beaconSetId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    event UpdatedBeaconSetWithSignedData(\n        bytes32 indexed dapiId,\n        int224 value,\n        uint32 timestamp\n    );\n\n    event AddedUnlimitedReader(address indexed unlimitedReader);\n\n    event SetDapiName(\n        bytes32 indexed dapiName,\n        bytes32 dataFeedId,\n        address indexed sender\n    );\n\n    function setRrpBeaconUpdatePermissionStatus(\n        address rrpBeaconUpdateRequester,\n        bool status\n    ) external;\n\n    function requestRrpBeaconUpdate(\n        address airnode,\n        bytes32 templateId,\n        address sponsor\n    ) external returns (bytes32 requestId);\n\n    function requestRrpBeaconUpdateRelayed(\n        address airnode,\n        bytes32 templateId,\n        address relayer,\n        address sponsor\n    ) external returns (bytes32 requestId);\n\n    function fulfillRrpBeaconUpdate(\n        bytes32 requestId,\n        uint256 timestamp,\n        bytes calldata data\n    ) external;\n\n    function registerBeaconUpdateSubscription(\n        address airnode,\n        bytes32 templateId,\n        bytes memory conditions,\n        address relayer,\n        address sponsor\n    ) external returns (bytes32 subscriptionId);\n\n    function conditionPspBeaconUpdate(\n        bytes32 subscriptionId,\n        bytes calldata data,\n        bytes calldata conditionParameters\n    ) external view returns (bool);\n\n    function fulfillPspBeaconUpdate(\n        bytes32 subscriptionId,\n        address airnode,\n        address relayer,\n        address sponsor,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external;\n\n    function updateBeaconWithSignedData(\n        address airnode,\n        bytes32 beaconId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external;\n\n    function updateBeaconSetWithBeacons(bytes32[] memory beaconIds)\n        external\n        returns (bytes32 beaconSetId);\n\n    function updateBeaconSetWithBeaconsAndReturnCondition(\n        bytes32[] memory beaconIds,\n        uint256 updateThresholdInPercentage\n    ) external returns (bool);\n\n    function conditionPspBeaconSetUpdate(\n        bytes32 subscriptionId,\n        bytes calldata data,\n        bytes calldata conditionParameters\n    ) external returns (bool);\n\n    function fulfillPspBeaconSetUpdate(\n        bytes32 subscriptionId,\n        address airnode,\n        address relayer,\n        address sponsor,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external;\n\n    function updateBeaconSetWithSignedData(\n        address[] memory airnodes,\n        bytes32[] memory templateIds,\n        uint256[] memory timestamps,\n        bytes[] memory data,\n        bytes[] memory signatures\n    ) external returns (bytes32 beaconSetId);\n\n    function addUnlimitedReader(address unlimitedReader) external;\n\n    function setDapiName(bytes32 dapiName, bytes32 dataFeedId) external;\n\n    function dapiNameToDataFeedId(bytes32 dapiName)\n        external\n        view\n        returns (bytes32);\n\n    function readDataFeedWithId(bytes32 dataFeedId)\n        external\n        view\n        returns (int224 value, uint32 timestamp);\n\n    function readDataFeedValueWithId(bytes32 dataFeedId)\n        external\n        view\n        returns (int224 value);\n\n    function readDataFeedWithDapiName(bytes32 dapiName)\n        external\n        view\n        returns (int224 value, uint32 timestamp);\n\n    function readDataFeedValueWithDapiName(bytes32 dapiName)\n        external\n        view\n        returns (int224 value);\n\n    function readerCanReadDataFeed(bytes32 dataFeedId, address reader)\n        external\n        view\n        returns (bool);\n\n    function dataFeedIdToReaderToWhitelistStatus(\n        bytes32 dataFeedId,\n        address reader\n    )\n        external\n        view\n        returns (uint64 expirationTimestamp, uint192 indefiniteWhitelistCount);\n\n    function dataFeedIdToReaderToSetterToIndefiniteWhitelistStatus(\n        bytes32 dataFeedId,\n        address reader,\n        address setter\n    ) external view returns (bool indefiniteWhitelistStatus);\n\n    function deriveBeaconId(address airnode, bytes32 templateId)\n        external\n        pure\n        returns (bytes32 beaconId);\n\n    function deriveBeaconSetId(bytes32[] memory beaconIds)\n        external\n        pure\n        returns (bytes32 beaconSetId);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function DAPI_NAME_SETTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function HUNDRED_PERCENT() external view returns (uint256);\n\n    function dapiNameSetterRole() external view returns (bytes32);\n\n    function sponsorToRrpBeaconUpdateRequesterToPermissionStatus(\n        address sponsor,\n        address updateRequester\n    ) external view returns (bool);\n\n    function subscriptionIdToBeaconId(bytes32 subscriptionId)\n        external\n        view\n        returns (bytes32);\n}\n"
    },
    "@openzeppelin/contracts/utils/cryptography/ECDSA.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/cryptography/ECDSA.sol)\n\npragma solidity ^0.8.0;\n\nimport \"../Strings.sol\";\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    enum RecoverError {\n        NoError,\n        InvalidSignature,\n        InvalidSignatureLength,\n        InvalidSignatureS,\n        InvalidSignatureV\n    }\n\n    function _throwError(RecoverError error) private pure {\n        if (error == RecoverError.NoError) {\n            return; // no error: do nothing\n        } else if (error == RecoverError.InvalidSignature) {\n            revert(\"ECDSA: invalid signature\");\n        } else if (error == RecoverError.InvalidSignatureLength) {\n            revert(\"ECDSA: invalid signature length\");\n        } else if (error == RecoverError.InvalidSignatureS) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        } else if (error == RecoverError.InvalidSignatureV) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature` or error string. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     *\n     * Documentation for signature generation:\n     * - with https://web3js.readthedocs.io/en/v1.3.4/web3-eth-accounts.html#sign[Web3.js]\n     * - with https://docs.ethers.io/v5/api/signer/#Signer-signMessage[ethers]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(bytes32 hash, bytes memory signature) internal pure returns (address, RecoverError) {\n        // Check the signature length\n        // - case 65: r,s,v signature (standard)\n        // - case 64: r,vs signature (cf https://eips.ethereum.org/EIPS/eip-2098) _Available since v4.1._\n        if (signature.length == 65) {\n            bytes32 r;\n            bytes32 s;\n            uint8 v;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                s := mload(add(signature, 0x40))\n                v := byte(0, mload(add(signature, 0x60)))\n            }\n            return tryRecover(hash, v, r, s);\n        } else if (signature.length == 64) {\n            bytes32 r;\n            bytes32 vs;\n            // ecrecover takes the signature parameters, and the only way to get them\n            // currently is to use assembly.\n            assembly {\n                r := mload(add(signature, 0x20))\n                vs := mload(add(signature, 0x40))\n            }\n            return tryRecover(hash, r, vs);\n        } else {\n            return (address(0), RecoverError.InvalidSignatureLength);\n        }\n    }\n\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, signature);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `r` and `vs` short-signature fields separately.\n     *\n     * See https://eips.ethereum.org/EIPS/eip-2098[EIP-2098 short signatures]\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address, RecoverError) {\n        bytes32 s;\n        uint8 v;\n        assembly {\n            s := and(vs, 0x7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff)\n            v := add(shr(255, vs), 27)\n        }\n        return tryRecover(hash, v, r, s);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `r and `vs` short-signature fields separately.\n     *\n     * _Available since v4.2._\n     */\n    function recover(\n        bytes32 hash,\n        bytes32 r,\n        bytes32 vs\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, r, vs);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Overload of {ECDSA-tryRecover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     *\n     * _Available since v4.3._\n     */\n    function tryRecover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address, RecoverError) {\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (301): 0 < s < secp256k1n  2 + 1, and for v in (302): v  {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            return (address(0), RecoverError.InvalidSignatureS);\n        }\n        if (v != 27 && v != 28) {\n            return (address(0), RecoverError.InvalidSignatureV);\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        if (signer == address(0)) {\n            return (address(0), RecoverError.InvalidSignature);\n        }\n\n        return (signer, RecoverError.NoError);\n    }\n\n    /**\n     * @dev Overload of {ECDSA-recover} that receives the `v`,\n     * `r` and `s` signature fields separately.\n     */\n    function recover(\n        bytes32 hash,\n        uint8 v,\n        bytes32 r,\n        bytes32 s\n    ) internal pure returns (address) {\n        (address recovered, RecoverError error) = tryRecover(hash, v, r, s);\n        _throwError(error);\n        return recovered;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from `s`. This\n     * produces hash corresponding to the one signed with the\n     * https://eth.wiki/json-rpc/API#eth_sign[`eth_sign`]\n     * JSON-RPC method as part of EIP-191.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes memory s) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n\", Strings.toString(s.length), s));\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Typed Data, created from a\n     * `domainSeparator` and a `structHash`. This produces hash corresponding\n     * to the one signed with the\n     * https://eips.ethereum.org/EIPS/eip-712[`eth_signTypedData`]\n     * JSON-RPC method as part of EIP-712.\n     *\n     * See {recover}.\n     */\n    function toTypedDataHash(bytes32 domainSeparator, bytes32 structHash) internal pure returns (bytes32) {\n        return keccak256(abi.encodePacked(\"\\x19\\x01\", domainSeparator, structHash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Multicall.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Multicall.sol)\n\npragma solidity ^0.8.0;\n\nimport \"./Address.sol\";\n\n/**\n * @dev Provides a function to batch together multiple calls in a single external call.\n *\n * _Available since v4.1._\n */\nabstract contract Multicall {\n    /**\n     * @dev Receives and executes a batch of function calls on this contract.\n     */\n    function multicall(bytes[] calldata data) external returns (bytes[] memory results) {\n        results = new bytes[](data.length);\n        for (uint256 i = 0; i < data.length; i++) {\n            results[i] = Address.functionDelegateCall(address(this), data[i]);\n        }\n        return results;\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Address.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // This method relies on extcodesize, which returns 0 for contracts in\n        // construction, since the code is only stored at the end of the\n        // constructor execution.\n\n        uint256 size;\n        assembly {\n            size := extcodesize(account)\n        }\n        return size > 0;\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        (bool success, ) = recipient.call{value: amount}(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason, it is bubbled up by this\n     * function (like regular Solidity function calls).\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCall(target, data, \"Address: low-level call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`], but with\n     * `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value\n    ) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, value, \"Address: low-level call with value failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCallWithValue-address-bytes-uint256-}[`functionCallWithValue`], but\n     * with `errorMessage` as a fallback revert reason when `target` reverts.\n     *\n     * _Available since v3.1._\n     */\n    function functionCallWithValue(\n        address target,\n        bytes memory data,\n        uint256 value,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(address(this).balance >= value, \"Address: insufficient balance for call\");\n        require(isContract(target), \"Address: call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        return functionStaticCall(target, data, \"Address: low-level static call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a static call.\n     *\n     * _Available since v3.3._\n     */\n    function functionStaticCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal view returns (bytes memory) {\n        require(isContract(target), \"Address: static call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionDelegateCall(target, data, \"Address: low-level delegate call failed\");\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-string-}[`functionCall`],\n     * but performing a delegate call.\n     *\n     * _Available since v3.4._\n     */\n    function functionDelegateCall(\n        address target,\n        bytes memory data,\n        string memory errorMessage\n    ) internal returns (bytes memory) {\n        require(isContract(target), \"Address: delegate call to non-contract\");\n\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResult(success, returndata, errorMessage);\n    }\n\n    /**\n     * @dev Tool to verifies that a low level call was successful, and revert if it wasn't, either by bubbling the\n     * revert reason using the provided one.\n     *\n     * _Available since v4.3._\n     */\n    function verifyCallResult(\n        bool success,\n        bytes memory returndata,\n        string memory errorMessage\n    ) internal pure returns (bytes memory) {\n        if (success) {\n            return returndata;\n        } else {\n            // Look for revert reason and bubble it up if present\n            if (returndata.length > 0) {\n                // The easiest way to bubble the revert reason is using memory via assembly\n\n                assembly {\n                    let returndata_size := mload(returndata)\n                    revert(add(32, returndata), returndata_size)\n                }\n            } else {\n                revert(errorMessage);\n            }\n        }\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/whitelist/Whitelist.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contract to be inherited by contracts that need temporary and\n/// permanent whitelists for services identified by hashes\n/// @notice This contract implements two kinds of whitelisting:\n///   (1) Temporary, ends when the expiration timestamp is in the past\n///   (2) Indefinite, ends when the indefinite whitelist count is zero\n/// Multiple senders can indefinitely whitelist/unwhitelist independently. The\n/// user will be considered whitelisted as long as there is at least one active\n/// indefinite whitelisting.\n/// @dev The interface of this contract is not implemented. It should be\n/// inherited and its functions should be exposed with a sort of an\n/// authorization scheme.\ncontract Whitelist {\n    struct WhitelistStatus {\n        uint64 expirationTimestamp;\n        uint192 indefiniteWhitelistCount;\n    }\n\n    mapping(bytes32 => mapping(address => WhitelistStatus))\n        internal serviceIdToUserToWhitelistStatus;\n\n    mapping(bytes32 => mapping(address => mapping(address => bool)))\n        internal serviceIdToUserToSetterToIndefiniteWhitelistStatus;\n\n    /// @notice Extends the expiration of the temporary whitelist of the user\n    /// for the service\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _extendWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) internal {\n        require(\n            expirationTimestamp >\n                serviceIdToUserToWhitelistStatus[serviceId][user]\n                    .expirationTimestamp,\n            \"Does not extend expiration\"\n        );\n        serviceIdToUserToWhitelistStatus[serviceId][user]\n            .expirationTimestamp = expirationTimestamp;\n    }\n\n    /// @notice Sets the expiration of the temporary whitelist of the user for\n    /// the service\n    /// @dev Unlike `extendWhitelistExpiration()`, this can hasten expiration\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param expirationTimestamp Timestamp at which the temporary whitelist\n    /// will expire\n    function _setWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) internal {\n        serviceIdToUserToWhitelistStatus[serviceId][user]\n            .expirationTimestamp = expirationTimestamp;\n    }\n\n    /// @notice Sets the indefinite whitelist status of the user for the\n    /// service\n    /// @dev As long as at least there is at least one account that has set the\n    /// indefinite whitelist status of the user for the service as true, the\n    /// user will be considered whitelisted\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param status Indefinite whitelist status\n    function _setIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        bool status\n    ) internal returns (uint192 indefiniteWhitelistCount) {\n        indefiniteWhitelistCount = serviceIdToUserToWhitelistStatus[serviceId][\n            user\n        ].indefiniteWhitelistCount;\n        if (\n            status &&\n            !serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][\n                user\n            ][msg.sender]\n        ) {\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                msg.sender\n            ] = true;\n            indefiniteWhitelistCount++;\n            serviceIdToUserToWhitelistStatus[serviceId][user]\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\n        } else if (\n            !status &&\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                msg.sender\n            ]\n        ) {\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                msg.sender\n            ] = false;\n            indefiniteWhitelistCount--;\n            serviceIdToUserToWhitelistStatus[serviceId][user]\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\n        }\n    }\n\n    /// @notice Revokes the indefinite whitelist status granted to the user for\n    /// the service by a specific account\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @param setter Setter of the indefinite whitelist status\n    function _revokeIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        address setter\n    ) internal returns (bool revoked, uint192 indefiniteWhitelistCount) {\n        indefiniteWhitelistCount = serviceIdToUserToWhitelistStatus[serviceId][\n            user\n        ].indefiniteWhitelistCount;\n        if (\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                setter\n            ]\n        ) {\n            serviceIdToUserToSetterToIndefiniteWhitelistStatus[serviceId][user][\n                setter\n            ] = false;\n            indefiniteWhitelistCount--;\n            serviceIdToUserToWhitelistStatus[serviceId][user]\n                .indefiniteWhitelistCount = indefiniteWhitelistCount;\n            revoked = true;\n        }\n    }\n\n    /// @notice Returns if the user is whitelised to use the service\n    /// @param serviceId Service ID\n    /// @param user User address\n    /// @return isWhitelisted If the user is whitelisted\n    function userIsWhitelisted(bytes32 serviceId, address user)\n        internal\n        view\n        returns (bool isWhitelisted)\n    {\n        WhitelistStatus\n            storage whitelistStatus = serviceIdToUserToWhitelistStatus[\n                serviceId\n            ][user];\n        return\n            whitelistStatus.indefiniteWhitelistCount > 0 ||\n            whitelistStatus.expirationTimestamp > block.timestamp;\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/whitelist/WhitelistRolesWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./WhitelistRoles.sol\";\nimport \"../access-control-registry/AccessControlRegistryAdminnedWithManager.sol\";\nimport \"./interfaces/IWhitelistRolesWithManager.sol\";\nimport \"../access-control-registry/interfaces/IAccessControlRegistry.sol\";\n\n/// @title Contract to be inherited by Whitelist contracts that will use\n/// roles where there is a single manager\ncontract WhitelistRolesWithManager is\n    WhitelistRoles,\n    AccessControlRegistryAdminnedWithManager,\n    IWhitelistRolesWithManager\n{\n    // Since there will be a single manager, we can derive the roles beforehand\n\n    /// @notice Whitelist expiration extender role\n    bytes32 public immutable override whitelistExpirationExtenderRole;\n\n    /// @notice Whitelist expiration setter role\n    bytes32 public immutable override whitelistExpirationSetterRole;\n\n    /// @notice Indefinite whitelister role\n    bytes32 public immutable override indefiniteWhitelisterRole;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        AccessControlRegistryAdminnedWithManager(\n            _accessControlRegistry,\n            _adminRoleDescription,\n            _manager\n        )\n    {\n        whitelistExpirationExtenderRole = _deriveRole(\n            adminRole,\n            WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION_HASH\n        );\n        whitelistExpirationSetterRole = _deriveRole(\n            adminRole,\n            WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION_HASH\n        );\n        indefiniteWhitelisterRole = _deriveRole(\n            adminRole,\n            INDEFINITE_WHITELISTER_ROLE_DESCRIPTION_HASH\n        );\n    }\n\n    /// @dev Returns if the account has the whitelist expiration extender role\n    /// or is the manager\n    /// @param account Account address\n    /// @return If the account has the whitelist extender role or is the\n    /// manager\n    function hasWhitelistExpirationExtenderRoleOrIsManager(address account)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            manager == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                whitelistExpirationExtenderRole,\n                account\n            );\n    }\n\n    /// @dev Returns if the account has the whitelist expriation setter role or\n    /// is the manager\n    /// @param account Account address\n    /// @return If the account has the whitelist setter role or is the\n    /// manager\n    function hasWhitelistExpirationSetterRoleOrIsManager(address account)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            manager == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                whitelistExpirationSetterRole,\n                account\n            );\n    }\n\n    /// @dev Returns if the account has the indefinite whitelister role or is the\n    /// manager\n    /// @param account Account address\n    /// @return If the account has the indefinite whitelister role or is the\n    /// manager\n    function hasIndefiniteWhitelisterRoleOrIsManager(address account)\n        internal\n        view\n        returns (bool)\n    {\n        return\n            manager == account ||\n            IAccessControlRegistry(accessControlRegistry).hasRole(\n                indefiniteWhitelisterRole,\n                account\n            );\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/whitelist/interfaces/IWhitelistWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IWhitelistRolesWithManager.sol\";\n\ninterface IWhitelistWithManager is IWhitelistRolesWithManager {\n    event ExtendedWhitelistExpiration(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetWhitelistExpiration(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed sender,\n        uint256 expiration\n    );\n\n    event SetIndefiniteWhitelistStatus(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed sender,\n        bool status,\n        uint192 indefiniteWhitelistCount\n    );\n\n    event RevokedIndefiniteWhitelistStatus(\n        bytes32 indexed serviceId,\n        address indexed user,\n        address indexed setter,\n        address sender,\n        uint192 indefiniteWhitelistCount\n    );\n\n    function extendWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setWhitelistExpiration(\n        bytes32 serviceId,\n        address user,\n        uint64 expirationTimestamp\n    ) external;\n\n    function setIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        bool status\n    ) external;\n\n    function revokeIndefiniteWhitelistStatus(\n        bytes32 serviceId,\n        address user,\n        address setter\n    ) external;\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/whitelist/WhitelistRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IWhitelistRoles.sol\";\n\n/// @title Contract to be inherited by Whitelist contracts that will use\n/// generic AccessControlRegistry roles\ncontract WhitelistRoles is IWhitelistRoles {\n    // There are four roles implemented in this contract:\n    // Root\n    //  (1) Admin (can grant and revoke the roles below)\n    //      (2) Whitelist expiration extender\n    //      (3) Whitelist expiration setter\n    //      (4) Indefinite whitelister\n    // Their IDs are derived from the descriptions below. Refer to\n    // AccessControlRegistry for more information.\n    // To clarify, the root role of the manager is the admin of (1), while (1)\n    // is the admin of (2), (3) and (4). So (1) is more of a \"contract admin\",\n    // while the `adminRole` used in AccessControl and AccessControlRegistry\n    // refers to a more general adminship relationship between roles.\n\n    /// @notice Whitelist expiration extender role description\n    string\n        public constant\n        override WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION =\n        \"Whitelist expiration extender\";\n\n    /// @notice Whitelist expiration setter role description\n    string\n        public constant\n        override WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION =\n        \"Whitelist expiration setter\";\n\n    /// @notice Indefinite whitelister role description\n\n    string public constant override INDEFINITE_WHITELISTER_ROLE_DESCRIPTION =\n        \"Indefinite whitelister\";\n\n    bytes32\n        internal constant WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION_HASH =\n        keccak256(\n            abi.encodePacked(WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION)\n        );\n\n    bytes32\n        internal constant WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION_HASH =\n        keccak256(\n            abi.encodePacked(WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION)\n        );\n\n    bytes32 internal constant INDEFINITE_WHITELISTER_ROLE_DESCRIPTION_HASH =\n        keccak256(abi.encodePacked(INDEFINITE_WHITELISTER_ROLE_DESCRIPTION));\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/access-control-registry/AccessControlRegistryAdminnedWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./AccessControlRegistryAdminned.sol\";\nimport \"./interfaces/IAccessControlRegistryAdminnedWithManager.sol\";\n\n/// @title Contract to be inherited by contracts with manager whose adminship\n/// functionality will be implemented using AccessControlRegistry\n/// @notice The manager address here is expected to belong to an\n/// AccessControlRegistry user that is a multisig/DAO\ncontract AccessControlRegistryAdminnedWithManager is\n    AccessControlRegistryAdminned,\n    IAccessControlRegistryAdminnedWithManager\n{\n    /// @notice Address of the manager that manages the related\n    /// AccessControlRegistry roles\n    /// @dev The mutability of the manager role can be implemented by\n    /// designating an OwnableCallForwarder contract as the manager. The\n    /// ownership of this contract can then be transferred, effectively\n    /// transferring managership.\n    address public immutable override manager;\n\n    /// @notice Admin role\n    /// @dev Since `manager` is immutable, so is `adminRole`\n    bytes32 public immutable override adminRole;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    /// @param _manager Manager address\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription,\n        address _manager\n    )\n        AccessControlRegistryAdminned(\n            _accessControlRegistry,\n            _adminRoleDescription\n        )\n    {\n        require(_manager != address(0), \"Manager address zero\");\n        manager = _manager;\n        adminRole = _deriveAdminRole(_manager);\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/whitelist/interfaces/IWhitelistRolesWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IWhitelistRoles.sol\";\nimport \"../../access-control-registry/interfaces/IAccessControlRegistryAdminnedWithManager.sol\";\n\ninterface IWhitelistRolesWithManager is\n    IWhitelistRoles,\n    IAccessControlRegistryAdminnedWithManager\n{\n    function whitelistExpirationExtenderRole() external view returns (bytes32);\n\n    function whitelistExpirationSetterRole() external view returns (bytes32);\n\n    function indefiniteWhitelisterRole() external view returns (bytes32);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/access-control-registry/interfaces/IAccessControlRegistry.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/access/IAccessControl.sol\";\n\ninterface IAccessControlRegistry is IAccessControl {\n    event InitializedManager(bytes32 indexed rootRole, address indexed manager);\n\n    event InitializedRole(\n        bytes32 indexed role,\n        bytes32 indexed adminRole,\n        string description,\n        address sender\n    );\n\n    function initializeManager(address manager) external;\n\n    function initializeRoleAndGrantToSender(\n        bytes32 adminRole,\n        string calldata description\n    ) external returns (bytes32 role);\n\n    function deriveRootRole(address manager)\n        external\n        pure\n        returns (bytes32 rootRole);\n\n    function deriveRole(bytes32 adminRole, string calldata description)\n        external\n        pure\n        returns (bytes32 role);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/whitelist/interfaces/IWhitelistRoles.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWhitelistRoles {\n    // solhint-disable-next-line func-name-mixedcase\n    function WHITELIST_EXPIRATION_EXTENDER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function WHITELIST_EXPIRATION_SETTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function INDEFINITE_WHITELISTER_ROLE_DESCRIPTION()\n        external\n        view\n        returns (string memory);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/access-control-registry/AccessControlRegistryAdminned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"@openzeppelin/contracts/utils/Multicall.sol\";\nimport \"./RoleDeriver.sol\";\nimport \"./AccessControlRegistryUser.sol\";\nimport \"./interfaces/IAccessControlRegistryAdminned.sol\";\n\n/// @title Contract to be inherited by contracts whose adminship functionality\n/// will be implemented using AccessControlRegistry\ncontract AccessControlRegistryAdminned is\n    Multicall,\n    RoleDeriver,\n    AccessControlRegistryUser,\n    IAccessControlRegistryAdminned\n{\n    /// @notice Admin role description\n    string public override adminRoleDescription;\n\n    bytes32 internal immutable adminRoleDescriptionHash;\n\n    /// @dev Contracts deployed with the same admin role descriptions will have\n    /// the same roles, meaning that granting an account a role will authorize\n    /// it in multiple contracts. Unless you want your deployed contract to\n    /// share the role configuration of another contract, use a unique admin\n    /// role description.\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    /// @param _adminRoleDescription Admin role description\n    constructor(\n        address _accessControlRegistry,\n        string memory _adminRoleDescription\n    ) AccessControlRegistryUser(_accessControlRegistry) {\n        require(\n            bytes(_adminRoleDescription).length > 0,\n            \"Admin role description empty\"\n        );\n        adminRoleDescription = _adminRoleDescription;\n        adminRoleDescriptionHash = keccak256(\n            abi.encodePacked(_adminRoleDescription)\n        );\n    }\n\n    /// @notice Derives the admin role for the specific manager address\n    /// @param manager Manager address\n    /// @return adminRole Admin role\n    function _deriveAdminRole(address manager)\n        internal\n        view\n        returns (bytes32 adminRole)\n    {\n        adminRole = _deriveRole(\n            _deriveRootRole(manager),\n            adminRoleDescriptionHash\n        );\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/access-control-registry/interfaces/IAccessControlRegistryAdminnedWithManager.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlRegistryAdminned.sol\";\n\ninterface IAccessControlRegistryAdminnedWithManager is\n    IAccessControlRegistryAdminned\n{\n    function manager() external view returns (address);\n\n    function adminRole() external view returns (bytes32);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/access-control-registry/RoleDeriver.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contract to be inherited by contracts that will derive\n/// AccessControlRegistry roles\n/// @notice If a contract interfaces with AccessControlRegistry and needs to\n/// derive roles, it should inherit this contract instead of re-implementing\n/// the logic\ncontract RoleDeriver {\n    /// @notice Derives the root role of the manager\n    /// @param manager Manager address\n    /// @return rootRole Root role\n    function _deriveRootRole(address manager)\n        internal\n        pure\n        returns (bytes32 rootRole)\n    {\n        rootRole = keccak256(abi.encodePacked(manager));\n    }\n\n    /// @notice Derives the role using its admin role and description\n    /// @dev This implies that roles adminned by the same role cannot have the\n    /// same description\n    /// @param adminRole Admin role\n    /// @param description Human-readable description of the role\n    /// @return role Role\n    function _deriveRole(bytes32 adminRole, string memory description)\n        internal\n        pure\n        returns (bytes32 role)\n    {\n        role = _deriveRole(adminRole, keccak256(abi.encodePacked(description)));\n    }\n\n    /// @notice Derives the role using its admin role and description hash\n    /// @dev This implies that roles adminned by the same role cannot have the\n    /// same description\n    /// @param adminRole Admin role\n    /// @param descriptionHash Hash of the human-readable description of the\n    /// role\n    /// @return role Role\n    function _deriveRole(bytes32 adminRole, bytes32 descriptionHash)\n        internal\n        pure\n        returns (bytes32 role)\n    {\n        role = keccak256(abi.encodePacked(adminRole, descriptionHash));\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/access-control-registry/AccessControlRegistryUser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./interfaces/IAccessControlRegistry.sol\";\nimport \"./interfaces/IAccessControlRegistryUser.sol\";\n\n/// @title Contract to be inherited by contracts that will interact with\n/// AccessControlRegistry\ncontract AccessControlRegistryUser is IAccessControlRegistryUser {\n    /// @notice AccessControlRegistry contract address\n    address public immutable override accessControlRegistry;\n\n    /// @param _accessControlRegistry AccessControlRegistry contract address\n    constructor(address _accessControlRegistry) {\n        require(_accessControlRegistry != address(0), \"ACR address zero\");\n        accessControlRegistry = _accessControlRegistry;\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/access-control-registry/interfaces/IAccessControlRegistryAdminned.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IAccessControlRegistryUser.sol\";\n\ninterface IAccessControlRegistryAdminned is IAccessControlRegistryUser {\n    function adminRoleDescription() external view returns (string memory);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/access-control-registry/interfaces/IAccessControlRegistryUser.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAccessControlRegistryUser {\n    function accessControlRegistry() external view returns (address);\n}\n"
    },
    "@openzeppelin/contracts/access/IAccessControl.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (access/IAccessControl.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev External interface of AccessControl declared to support ERC165 detection.\n */\ninterface IAccessControl {\n    /**\n     * @dev Emitted when `newAdminRole` is set as ``role``'s admin role, replacing `previousAdminRole`\n     *\n     * `DEFAULT_ADMIN_ROLE` is the starting admin for all roles, despite\n     * {RoleAdminChanged} not being emitted signaling this.\n     *\n     * _Available since v3.1._\n     */\n    event RoleAdminChanged(bytes32 indexed role, bytes32 indexed previousAdminRole, bytes32 indexed newAdminRole);\n\n    /**\n     * @dev Emitted when `account` is granted `role`.\n     *\n     * `sender` is the account that originated the contract call, an admin role\n     * bearer except when using {AccessControl-_setupRole}.\n     */\n    event RoleGranted(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Emitted when `account` is revoked `role`.\n     *\n     * `sender` is the account that originated the contract call:\n     *   - if using `revokeRole`, it is the admin role bearer\n     *   - if using `renounceRole`, it is the role bearer (i.e. `account`)\n     */\n    event RoleRevoked(bytes32 indexed role, address indexed account, address indexed sender);\n\n    /**\n     * @dev Returns `true` if `account` has been granted `role`.\n     */\n    function hasRole(bytes32 role, address account) external view returns (bool);\n\n    /**\n     * @dev Returns the admin role that controls `role`. See {grantRole} and\n     * {revokeRole}.\n     *\n     * To change a role's admin, use {AccessControl-_setRoleAdmin}.\n     */\n    function getRoleAdmin(bytes32 role) external view returns (bytes32);\n\n    /**\n     * @dev Grants `role` to `account`.\n     *\n     * If `account` had not been already granted `role`, emits a {RoleGranted}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function grantRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from `account`.\n     *\n     * If `account` had been granted `role`, emits a {RoleRevoked} event.\n     *\n     * Requirements:\n     *\n     * - the caller must have ``role``'s admin role.\n     */\n    function revokeRole(bytes32 role, address account) external;\n\n    /**\n     * @dev Revokes `role` from the calling account.\n     *\n     * Roles are often managed via {grantRole} and {revokeRole}: this function's\n     * purpose is to provide a mechanism for accounts to lose their privileges\n     * if they are compromised (such as when a trusted device is misplaced).\n     *\n     * If the calling account had been granted `role`, emits a {RoleRevoked}\n     * event.\n     *\n     * Requirements:\n     *\n     * - the caller must be `account`.\n     */\n    function renounceRole(bytes32 role, address account) external;\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/protocol/interfaces/IAirnodeProtocol.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\nimport \"./IStorageUtils.sol\";\nimport \"./ISponsorshipUtils.sol\";\nimport \"./IWithdrawalUtils.sol\";\n\ninterface IAirnodeProtocol is\n    IStorageUtils,\n    ISponsorshipUtils,\n    IWithdrawalUtils\n{\n    event MadeRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        address requester,\n        uint256 requesterRequestCount,\n        bytes32 templateId,\n        bytes parameters,\n        address sponsor,\n        bytes4 fulfillFunctionId\n    );\n\n    event FulfilledRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        uint256 timestamp,\n        bytes data\n    );\n\n    event FailedRequest(\n        address indexed airnode,\n        bytes32 indexed requestId,\n        uint256 timestamp,\n        string errorMessage\n    );\n\n    event MadeRequestRelayed(\n        address indexed relayer,\n        bytes32 indexed requestId,\n        address indexed airnode,\n        address requester,\n        uint256 requesterRequestCount,\n        bytes32 templateId,\n        bytes parameters,\n        address sponsor,\n        bytes4 fulfillFunctionId\n    );\n\n    event FulfilledRequestRelayed(\n        address indexed relayer,\n        bytes32 indexed requestId,\n        address indexed airnode,\n        uint256 timestamp,\n        bytes data\n    );\n\n    event FailedRequestRelayed(\n        address indexed relayer,\n        bytes32 indexed requestId,\n        address indexed airnode,\n        uint256 timestamp,\n        string errorMessage\n    );\n\n    function makeRequest(\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        address sponsor,\n        bytes4 fulfillFunctionId\n    ) external returns (bytes32 requestId);\n\n    function fulfillRequest(\n        bytes32 requestId,\n        address airnode,\n        address requester,\n        bytes4 fulfillFunctionId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external returns (bool callSuccess, bytes memory callData);\n\n    function failRequest(\n        bytes32 requestId,\n        address airnode,\n        address requester,\n        bytes4 fulfillFunctionId,\n        uint256 timestamp,\n        string calldata errorMessage,\n        bytes calldata signature\n    ) external;\n\n    function makeRequestRelayed(\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        address relayer,\n        address sponsor,\n        bytes4 fulfillFunctionId\n    ) external returns (bytes32 requestId);\n\n    function fulfillRequestRelayed(\n        bytes32 requestId,\n        address airnode,\n        address requester,\n        address relayer,\n        bytes4 fulfillFunctionId,\n        uint256 timestamp,\n        bytes calldata data,\n        bytes calldata signature\n    ) external returns (bool callSuccess, bytes memory callData);\n\n    function failRequestRelayed(\n        bytes32 requestId,\n        address airnode,\n        address requester,\n        address relayer,\n        bytes4 fulfillFunctionId,\n        uint256 timestamp,\n        string calldata errorMessage,\n        bytes calldata signature\n    ) external;\n\n    function requestIsAwaitingFulfillment(bytes32 requestId)\n        external\n        view\n        returns (bool);\n\n    function requesterToRequestCount(address requester)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/protocol/interfaces/IAirnodeRequester.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IAirnodeRequester {\n    function airnodeProtocol() external view returns (address);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/protocol/interfaces/IStorageUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IStorageUtils {\n    event StoredTemplate(\n        bytes32 indexed templateId,\n        bytes32 endpointId,\n        bytes parameters\n    );\n\n    event StoredSubscription(\n        bytes32 indexed subscriptionId,\n        uint256 chainId,\n        address airnode,\n        bytes32 templateId,\n        bytes parameters,\n        bytes conditions,\n        address relayer,\n        address sponsor,\n        address requester,\n        bytes4 fulfillFunctionId\n    );\n\n    function storeTemplate(bytes32 endpointId, bytes calldata parameters)\n        external\n        returns (bytes32 templateId);\n\n    function storeSubscription(\n        uint256 chainId,\n        address airnode,\n        bytes32 templateId,\n        bytes calldata parameters,\n        bytes calldata conditions,\n        address relayer,\n        address sponsor,\n        address requester,\n        bytes4 fulfillFunctionId\n    ) external returns (bytes32 subscriptionId);\n\n    // solhint-disable-next-line func-name-mixedcase\n    function MAXIMUM_PARAMETER_LENGTH() external view returns (uint256);\n\n    function templates(bytes32 templateId)\n        external\n        view\n        returns (bytes32 endpointId, bytes memory parameters);\n\n    function subscriptions(bytes32 subscriptionId)\n        external\n        view\n        returns (\n            uint256 chainId,\n            address airnode,\n            bytes32 templateId,\n            bytes memory parameters,\n            bytes memory conditions,\n            address relayer,\n            address sponsor,\n            address requester,\n            bytes4 fulfillFunctionId\n        );\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/protocol/interfaces/ISponsorshipUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface ISponsorshipUtils {\n    event SetRrpSponsorshipStatus(\n        address indexed sponsor,\n        address indexed requester,\n        bool status\n    );\n\n    event SetPspSponsorshipStatus(\n        address indexed sponsor,\n        bytes32 indexed subscriptionId,\n        bool status\n    );\n\n    function setRrpSponsorshipStatus(address requester, bool status) external;\n\n    function setPspSponsorshipStatus(bytes32 subscriptionId, bool status)\n        external;\n\n    function sponsorToRequesterToRrpSponsorshipStatus(\n        address sponsor,\n        address requester\n    ) external view returns (bool status);\n\n    function sponsorToSubscriptionIdToPspSponsorshipStatus(\n        address sponsor,\n        bytes32 subscriptionId\n    ) external view returns (bool status);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/protocol/interfaces/IWithdrawalUtils.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\ninterface IWithdrawalUtils {\n    event RequestedWithdrawal(\n        address indexed airnodeOrRelayer,\n        address indexed sponsor,\n        bytes32 indexed withdrawalRequestId,\n        uint256 protocolId\n    );\n\n    event FulfilledWithdrawal(\n        address indexed airnodeOrRelayer,\n        address indexed sponsor,\n        bytes32 indexed withdrawalRequestId,\n        uint256 protocolId,\n        address sponsorWallet,\n        uint256 amount\n    );\n\n    event ClaimedBalance(address indexed sponsor, uint256 amount);\n\n    function requestWithdrawal(address airnodeOrRelayer, uint256 protocolId)\n        external;\n\n    function fulfillWithdrawal(\n        bytes32 withdrawalRequestId,\n        address airnodeOrRelayer,\n        uint256 protocolId,\n        address sponsor,\n        uint256 timestamp,\n        bytes calldata signature\n    ) external payable;\n\n    function claimBalance() external;\n\n    function withdrawalRequestIsAwaitingFulfillment(bytes32 withdrawalRequestId)\n        external\n        view\n        returns (bool);\n\n    function sponsorToBalance(address sponsor) external view returns (uint256);\n\n    function sponsorToWithdrawalRequestCount(address sponsor)\n        external\n        view\n        returns (uint256);\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/dapis/Sort.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contract to be inherited by contracts that will sort an array using\n/// an unrolled implementation\n/// @notice The operation will be in-place, i.e., the array provided as the\n/// argument will be modified.\ncontract Sort {\n    uint256 internal constant MAX_SORT_LENGTH = 9;\n\n    /// @notice Sorts the array\n    /// @param array Array to be sorted\n    function sort(int256[] memory array) internal pure {\n        uint256 arrayLength = array.length;\n        require(arrayLength <= MAX_SORT_LENGTH, \"Array too long to sort\");\n        // Do a binary search\n        if (arrayLength < 6) {\n            // Possible lengths: 1, 2, 3, 4, 5\n            if (arrayLength < 4) {\n                // Possible lengths: 1, 2, 3\n                if (arrayLength == 3) {\n                    // Length: 3\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 0, 1);\n                } else if (arrayLength == 2) {\n                    // Length: 2\n                    swapIfFirstIsLarger(array, 0, 1);\n                }\n                // Do nothing for Length: 1\n            } else {\n                // Possible lengths: 4, 5\n                if (arrayLength == 5) {\n                    // Length: 5\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 0, 3);\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 1, 2);\n                } else {\n                    // Length: 4\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 1, 2);\n                }\n            }\n        } else {\n            // Possible lengths: 6, 7, 8, 9\n            if (arrayLength < 8) {\n                // Possible lengths: 6, 7\n                if (arrayLength == 7) {\n                    // Length: 7\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 5, 6);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 4, 6);\n                    swapIfFirstIsLarger(array, 3, 5);\n                    swapIfFirstIsLarger(array, 2, 6);\n                    swapIfFirstIsLarger(array, 1, 5);\n                    swapIfFirstIsLarger(array, 0, 4);\n                    swapIfFirstIsLarger(array, 2, 5);\n                    swapIfFirstIsLarger(array, 0, 3);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                } else {\n                    // Length: 6\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 3, 5);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 2, 3);\n                }\n            } else {\n                // Possible lengths: 8, 9\n                if (arrayLength == 9) {\n                    // Length: 9\n                    swapIfFirstIsLarger(array, 1, 8);\n                    swapIfFirstIsLarger(array, 2, 7);\n                    swapIfFirstIsLarger(array, 3, 6);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 1, 4);\n                    swapIfFirstIsLarger(array, 5, 8);\n                    swapIfFirstIsLarger(array, 0, 2);\n                    swapIfFirstIsLarger(array, 6, 7);\n                    swapIfFirstIsLarger(array, 2, 6);\n                    swapIfFirstIsLarger(array, 7, 8);\n                    swapIfFirstIsLarger(array, 0, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 3, 5);\n                    swapIfFirstIsLarger(array, 6, 7);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 1, 3);\n                    swapIfFirstIsLarger(array, 5, 7);\n                    swapIfFirstIsLarger(array, 4, 6);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 5, 6);\n                    swapIfFirstIsLarger(array, 7, 8);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                } else {\n                    // Length: 8\n                    swapIfFirstIsLarger(array, 0, 7);\n                    swapIfFirstIsLarger(array, 1, 6);\n                    swapIfFirstIsLarger(array, 2, 5);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 0, 3);\n                    swapIfFirstIsLarger(array, 4, 7);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 5, 6);\n                    swapIfFirstIsLarger(array, 0, 1);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 6, 7);\n                    swapIfFirstIsLarger(array, 3, 5);\n                    swapIfFirstIsLarger(array, 2, 4);\n                    swapIfFirstIsLarger(array, 1, 2);\n                    swapIfFirstIsLarger(array, 3, 4);\n                    swapIfFirstIsLarger(array, 5, 6);\n                    swapIfFirstIsLarger(array, 2, 3);\n                    swapIfFirstIsLarger(array, 4, 5);\n                    swapIfFirstIsLarger(array, 3, 4);\n                }\n            }\n        }\n    }\n\n    /// @notice Swaps two elements of an array if the first element is greater\n    /// than the second\n    /// @param array Array whose elements are to be swapped\n    /// @param ind1 Index of the first element\n    /// @param ind2 Index of the second element\n    function swapIfFirstIsLarger(\n        int256[] memory array,\n        uint256 ind1,\n        uint256 ind2\n    ) private pure {\n        if (array[ind1] > array[ind2]) {\n            (array[ind1], array[ind2]) = (array[ind2], array[ind1]);\n        }\n    }\n}\n"
    },
    "@api3/airnode-protocol-v1/contracts/dapis/QuickSelect.sol": {
      "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.0;\n\n/// @title Contract to be inherited by contracts that will calculate the index\n/// of the k-th and optionally (k+1)-th largest elements in the array\n/// @notice Uses quickselect, which operates in-place, i.e., the array provided\n/// as the argument will be modified.\ncontract Quickselect {\n    /// @notice Returns the index of the k-th largest element in the array\n    /// @param array Array in which k-th largest element will be searched\n    /// @param k K\n    /// @return indK Index of the k-th largest element\n    function quickselectK(int256[] memory array, uint256 k)\n        internal\n        pure\n        returns (uint256 indK)\n    {\n        (indK, ) = quickselect(array, 0, array.length - 1, k, false);\n    }\n\n    /// @notice Returns the index of the k-th and (k+1)-th largest elements in\n    /// the array\n    /// @param array Array in which k-th and (k+1)-th largest elements will be\n    /// searched\n    /// @param k K\n    /// @return indK Index of the k-th largest element\n    /// @return indKPlusOne Index of the (k+1)-th largest element\n    function quickselectKPlusOne(int256[] memory array, uint256 k)\n        internal\n        pure\n        returns (uint256 indK, uint256 indKPlusOne)\n    {\n        uint256 arrayLength = array.length;\n        require(arrayLength > 1, \"Array too short to select k+1\");\n        return quickselect(array, 0, arrayLength - 1, k, true);\n    }\n\n    /// @notice Returns the index of the k-th largest element in the specified\n    /// section of the (potentially unsorted) array\n    /// @param array Array in which K will be searched for\n    /// @param lo Starting index of the section of the array that K will be\n    /// searched in\n    /// @param hi Last index of the section of the array that K will be\n    /// searched in\n    /// @param k K\n    /// @param selectKPlusOne If the index of the (k+1)-th largest element is\n    /// to be returned\n    /// @return indK Index of the k-th largest element\n    /// @return indKPlusOne Index of the (k+1)-th largest element (only set if\n    /// `selectKPlusOne` is `true`)\n    function quickselect(\n        int256[] memory array,\n        uint256 lo,\n        uint256 hi,\n        uint256 k,\n        bool selectKPlusOne\n    ) private pure returns (uint256 indK, uint256 indKPlusOne) {\n        if (lo == hi) {\n            return (k, 0);\n        }\n        uint256 indPivot = partition(array, lo, hi);\n        if (k < indPivot) {\n            (indK, ) = quickselect(array, lo, indPivot - 1, k, false);\n        } else if (k > indPivot) {\n            (indK, ) = quickselect(array, indPivot + 1, hi, k, false);\n        } else {\n            indK = indPivot;\n        }\n        // Since Quickselect ends in the array being partitioned around the\n        // k-th largest element, we can continue searching towards right for\n        // the (k+1)-th largest element, which is useful in calculating the\n        // median of an array with even length\n        if (selectKPlusOne) {\n            indKPlusOne = indK + 1;\n            for (uint256 i = indKPlusOne + 1; i < array.length; i++) {\n                if (array[i] < array[indKPlusOne]) {\n                    indKPlusOne = i;\n                }\n            }\n        }\n    }\n\n    /// @notice Partitions the array into two around a pivot\n    /// @param array Array that will be partitioned\n    /// @param lo Starting index of the section of the array that will be\n    /// partitioned\n    /// @param hi Last index of the section of the array that will be\n    /// partitioned\n    /// @return pivotInd Pivot index\n    function partition(\n        int256[] memory array,\n        uint256 lo,\n        uint256 hi\n    ) private pure returns (uint256 pivotInd) {\n        if (lo == hi) {\n            return lo;\n        }\n        int256 pivot = array[lo];\n        uint256 i = lo;\n        pivotInd = hi + 1;\n        while (true) {\n            do {\n                i++;\n            } while (i < array.length && array[i] < pivot);\n            do {\n                pivotInd--;\n            } while (array[pivotInd] > pivot);\n            if (i >= pivotInd) {\n                (array[lo], array[pivotInd]) = (array[pivotInd], array[lo]);\n                return pivotInd;\n            }\n            (array[i], array[pivotInd]) = (array[pivotInd], array[i]);\n        }\n    }\n}\n"
    },
    "@openzeppelin/contracts/utils/Strings.sol": {
      "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts v4.4.1 (utils/Strings.sol)\n\npragma solidity ^0.8.0;\n\n/**\n * @dev String operations.\n */\nlibrary Strings {\n    bytes16 private constant _HEX_SYMBOLS = \"0123456789abcdef\";\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` decimal representation.\n     */\n    function toString(uint256 value) internal pure returns (string memory) {\n        // Inspired by OraclizeAPI's implementation - MIT licence\n        // https://github.com/oraclize/ethereum-api/blob/b42146b063c7d6ee1358846c198246239e9360e8/oraclizeAPI_0.4.25.sol\n\n        if (value == 0) {\n            return \"0\";\n        }\n        uint256 temp = value;\n        uint256 digits;\n        while (temp != 0) {\n            digits++;\n            temp /= 10;\n        }\n        bytes memory buffer = new bytes(digits);\n        while (value != 0) {\n            digits -= 1;\n            buffer[digits] = bytes1(uint8(48 + uint256(value % 10)));\n            value /= 10;\n        }\n        return string(buffer);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation.\n     */\n    function toHexString(uint256 value) internal pure returns (string memory) {\n        if (value == 0) {\n            return \"0x00\";\n        }\n        uint256 temp = value;\n        uint256 length = 0;\n        while (temp != 0) {\n            length++;\n            temp >>= 8;\n        }\n        return toHexString(value, length);\n    }\n\n    /**\n     * @dev Converts a `uint256` to its ASCII `string` hexadecimal representation with fixed length.\n     */\n    function toHexString(uint256 value, uint256 length) internal pure returns (string memory) {\n        bytes memory buffer = new bytes(2 * length + 2);\n        buffer[0] = \"0\";\n        buffer[1] = \"x\";\n        for (uint256 i = 2 * length + 1; i > 1; --i) {\n            buffer[i] = _HEX_SYMBOLS[value & 0xf];\n            value >>= 4;\n        }\n        require(value == 0, \"Strings: hex length insufficient\");\n        return string(buffer);\n    }\n}\n"
    }
  },
  "settings": {
    "optimizer": {
      "enabled": true,
      "runs": 1000
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers",
          "metadata",
          "devdoc",
          "userdoc",
          "storageLayout",
          "evm.gasEstimates"
        ],
        "": ["ast"]
      }
    },
    "metadata": {
      "useLiteralContent": true
    }
  }
}
