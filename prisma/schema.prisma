generator client {
  provider = "prisma-client-js"
}

generator erd {
  provider                  = "prisma-erd-generator"
  theme                     = "forest"
  includeRelationFromFields = true
}

generator PrismaTypeGraphQLTypesGenerator {
  provider     = "yarn prisma-typegraphql-types-generator"
  modelsOutput = "./src/models" // Optional defaults to "./src/generated/models"
  enumsOutput  = "./src/types/enums" // Optional defaults to "./src/generated/enums"
  useYarn      = true // Optional if you want `graphql-scalars` installation to be done via yarn defaults to "npm"
  //exportedNameSuffix = "GQL" // Optional if you want to add a suffix to the end of your exported class names and enums
  //exportedNamePrefix = "TYPE" // Optional if you want to prefix your exported class names and enums
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL") // eg = "postgresql://johndoe:mypassword@localhost:5432/mydb?schema=public"
}

// Notes
// Postgres DOMAIN not supported :( https://github.com/prisma/prisma/issues/1796
// https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#postgresql
// have to create checks as a migration

model Provider {
  name                  String       @id @db.Text
  active                Boolean      @db.Boolean
  description           String       @db.Text
  homepage              String       @db.Text
  airnodeAddress        String // evm address constraint
  xpub                  String       @db.Text
  logoPath              String       @db.Text
  orderLogoPath         String?      @db.Text
  maxSubscriptionPeriod Int
  beacon                Beacon[]
  deployment            Deployment[]
  updatedAt             DateTime     @updatedAt
}

model Beacon {
  beaconId     String               @id @db.Text
  name         String               @unique @db.Text
  description  String
  provider     Provider             @relation(fields: [providerName], references: [name])
  template     Template             @relation(fields: [templateId], references: [templateId])
  templateId   String
  chains       ChainConfiguration[]
  providerName String               @db.Text
  updatedAt    DateTime             @updatedAt
}

enum WalletType {
  Provider
  ProviderSponsor
  API3
  API3Sponsor
}

model TopUpWallet {
  id                   String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  address              String
  walletType           WalletType
  updatedAt            DateTime            @updatedAt
  ChainConfiguration   ChainConfiguration? @relation(fields: [chainConfigurationId], references: [id])
  chainConfigurationId String?             @db.Uuid
}

model Template {
  templateId String   @id
  name       String
  endpointId String
  parameters String
  beacon     Beacon[]
  updatedAt  DateTime @updatedAt
}

model ChainConfiguration {
  id                      String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  beacon                  Beacon?             @relation(fields: [beaconBeaconId], references: [beaconId])
  chain                   ChainInfrastructure @relation(fields: [chainInfrastructureName], references: [name])
  active                  Boolean
  sponsor                 String
  topUpWallet             TopUpWallet[]
  airSeekerConfig         Json
  beaconSet               BeaconSet?          @relation(fields: [beaconSetDataFeedId], references: [dataFeedId])
  beaconSetDataFeedId     String?
  updatedAt               DateTime            @updatedAt
  beaconBeaconId          String?             @db.Text
  chainInfrastructureName String
}

model OIS {
  id         String       @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  ois        Json
  deployment Deployment[]
  updatedAt  DateTime     @updatedAt
}

model Deployment {
  id                String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  chainApiReference String
  airnodeVersion    String
  config            Json
  ois               OIS      @relation(fields: [oisId], references: [id])
  oisId             String   @db.Uuid
  provider          Provider @relation(fields: [providerName], references: [name])
  providerName      String   @db.Text
  updatedAt         DateTime @updatedAt
}

model BeaconSet {
  dataFeedId   String               @id
  name         String
  description  String
  beaconIds    String[]
  activeChains ChainConfiguration[]
  updatedAt    DateTime             @updatedAt
  aApi         DApi[]
}

model DeployedContract {
  id                      String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  name                    String
  address                 String
  chainInfrastructure     ChainInfrastructure @relation(fields: [chainInfrastructureName], references: [name])
  chainInfrastructureName String
  updatedAt               DateTime            @updatedAt
}

model ChainInfrastructure {
  name               String               @id
  fullName           String               @unique
  decimalPlaces      Int
  id                 Int                  @unique
  contracts          DeployedContract[]
  nativeToken        String               @unique
  blockTime          Float?
  logoPath           String
  explorerUrl        String
  testnet            Boolean
  coverage           Coverage[]
  dApiMetadata       DApiMetadata[]
  chainConfiguration ChainConfiguration[]
  orderLogoPath      String?
  updatedAt          DateTime             @updatedAt
}

model DApi {
  name                String           @id
  dataFeedId          BeaconSet        @relation(fields: [beaconSetDataFeedId], references: [dataFeedId])
  updatedAt           DateTime         @updatedAt
  beaconSetDataFeedId String
  coveragePolicy      CoveragePolicy[]
}

model Category {
  name           String           @id
  beaconMetadata BeaconMetadata[]
  updatedAt      DateTime         @updatedAt
}

model Coverage {
  id                      String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  chainName               ChainInfrastructure @relation(fields: [chainInfrastructureName], references: [name])
  chainInfrastructureName String
  beaconMetadata          BeaconMetadata?     @relation(fields: [beaconMetadataBeaconId], references: [beaconId])
  beaconMetadataBeaconId  String?
  dApiMetadata            DApiMetadata?       @relation(fields: [dApiMetadataName], references: [name])
  dApiMetadataName        String?
  updatedAt               DateTime            @updatedAt
  coverageOptions         Json
}

model Logo {
  name                   String          @id
  url                    String
  beaconMetadata         BeaconMetadata? @relation(fields: [beaconMetadataBeaconId], references: [beaconId])
  beaconMetadataBeaconId String?
  aApiMetadata           DApiMetadata?   @relation(fields: [dApiMetadataName], references: [name])
  dApiMetadataName       String?
  updatedAt              DateTime        @updatedAt
}

model BeaconMetadata {
  beaconId      String     @id
  category      Category   @relation(fields: [categoryName], references: [name])
  coverage      Coverage[]
  decimalPlaces Int
  logos         Logo[]
  prefix        String
  postfix       String
  categoryName  String
  updatedAt     DateTime   @updatedAt
}

model DApiMetadata {
  name                    String              @id
  chain                   ChainInfrastructure @relation(fields: [chainInfrastructureName], references: [name])
  coverage                Coverage[]
  decimalPlaces           Int
  logos                   Logo[]
  prefix                  String
  postfix                 String
  chainInfrastructureName String
  updatedAt               DateTime            @updatedAt
}

enum ClientTransactionType {
  CoveragePurchase
  Deposit
  Withdrawal
}

// Represents a transaction on a client's account
model ClientTransaction {
  id                    String                @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  when                  DateTime              @default(dbgenerated("now()"))
  clientTransactionType ClientTransactionType
  paymentType           PaymentType
  Reference             String?
  transactionHash       String?
  detail                String
  notes                 String
  clientAccount         ClientAccount         @relation(fields: [clientAccountId], references: [id])
  clientAccountId       String                @db.Uuid
  coveragePolicy        CoveragePolicy[]
  coverageQuote         CoverageQuote?        @relation(fields: [coverageQuoteId], references: [id])
  coverageQuoteId       String?               @db.Uuid
}

enum PaymentType {
  USDC
  Ethereum
  USDWire
}

model BankingDetails {
  id              String         @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  type            PaymentType
  detail          String
  verified        DateTime?
  clientAccount   ClientAccount? @relation(fields: [clientAccountId], references: [id])
  clientAccountId String?        @db.Uuid
}

model ClientAccount {
  id                  String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  clientTransactionId String              @db.Uuid
  clientTransactions  ClientTransaction[]
  coverageClient      CoverageClient[]
  balance             Decimal
  bankingDetails      BankingDetails[]
}

model CoverageClient {
  id              String           @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  firstName       String
  lastName        String
  clientAccount   ClientAccount    @relation(fields: [clientAccountId], references: [id])
  clientAccountId String           @db.Uuid
  coveragePolicy  CoveragePolicy[]
}

model CoverageQuote {
  id                String              @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  amount            Decimal
  expiry            DateTime
  createdAt         DateTime            @default(dbgenerated("now()"))
  coveragePolicy    CoveragePolicy[]
  sentToClient      Json
  clientTransaction ClientTransaction[]
}

model CoveragePolicy {
  id                    String            @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  coverageClient        CoverageClient    @relation(fields: [coverageClientId], references: [id])
  dApi                  DApi              @relation(fields: [dApiName], references: [name])
  clientTransaction     ClientTransaction @relation(fields: [clientTransactionId], references: [id])
  claimantAddress       String?
  beneficiaryAddress    String?
  readerAddress         String
  coverageAmount        Decimal
  startDate             DateTime
  endDate               DateTime
  ipfsPolicyHash        String?
  ipfsServicePolicyHash String
  metadata              Json?
  updatedAt             DateTime          @updatedAt
  coverageClientId      String            @db.Uuid
  dApiName              String
  clientTransactionId   String            @db.Uuid
  coverageQuote         CoverageQuote     @relation(fields: [coverageQuoteId], references: [id])
  active                Boolean
  coverageQuoteId       String            @db.Uuid
}

model BlockCheck {
  id          Int @id
  chainId     Int
  blockNumber Int

  @@unique([chainId, blockNumber])
  @@index([blockNumber])
  @@index([chainId])
}

model ChainEvent {
  id              String   @id @default(dbgenerated("gen_random_uuid()")) @db.Uuid
  when            DateTime
  blockNumber     Int
  sourceContract  String
  transactionHash String
  eventIndex      Int
  eventType       String
  eventData       Json

  @@unique([blockNumber, sourceContract, transactionHash, eventIndex])
  @@index([blockNumber])
  @@index([when])
  @@index([sourceContract])
  @@index([transactionHash])
  @@index([eventType])
}
